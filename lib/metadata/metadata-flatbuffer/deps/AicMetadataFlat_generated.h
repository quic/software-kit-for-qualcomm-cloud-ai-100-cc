// Copyright (c) 2021-2024 Qualcomm Innovation Center, Inc. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause-Clear

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AICMETADATAFLAT_AICMETADATAFLAT_H_
#define FLATBUFFERS_GENERATED_AICMETADATAFLAT_AICMETADATAFLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace AicMetadataFlat {

struct AICMDSemaphoreOp;
struct AICMDSemaphoreOpBuilder;
struct AICMDSemaphoreOpT;

struct AICMDDoorbellOp;
struct AICMDDoorbellOpBuilder;
struct AICMDDoorbellOpT;

struct AICMDPortEntry;

struct AICMDDMARequest;
struct AICMDDMARequestBuilder;
struct AICMDDMARequestT;

struct AICMDNSPMulticastEntry;
struct AICMDNSPMulticastEntryBuilder;
struct AICMDNSPMulticastEntryT;

struct AICMDNSPMulticastEntryTable;
struct AICMDNSPMulticastEntryTableBuilder;
struct AICMDNSPMulticastEntryTableT;

struct AICMDHostMulticastEntry;
struct AICMDHostMulticastEntryBuilder;
struct AICMDHostMulticastEntryT;

struct AICMDHostMulticastEntryTable;
struct AICMDHostMulticastEntryTableBuilder;
struct AICMDHostMulticastEntryTableT;

struct AICMDThreadDescriptor;
struct AICMDThreadDescriptorBuilder;
struct AICMDThreadDescriptorT;

struct AICMDConstantMapping;
struct AICMDConstantMappingBuilder;
struct AICMDConstantMappingT;

struct QNNConfigDef;
struct QNNConfigDefBuilder;
struct QNNConfigDefT;

struct networkHeapBehaviorDef;
struct networkHeapBehaviorDefBuilder;
struct networkHeapBehaviorDefT;

struct NonZeroRegion;
struct NonZeroRegionBuilder;
struct NonZeroRegionT;

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

inline const flatbuffers::TypeTable *AICMDSemaphoreOpTypeTable();

inline const flatbuffers::TypeTable *AICMDDoorbellOpTypeTable();

inline const flatbuffers::TypeTable *AICMDPortEntryTypeTable();

inline const flatbuffers::TypeTable *AICMDDMARequestTypeTable();

inline const flatbuffers::TypeTable *AICMDNSPMulticastEntryTypeTable();

inline const flatbuffers::TypeTable *AICMDNSPMulticastEntryTableTypeTable();

inline const flatbuffers::TypeTable *AICMDHostMulticastEntryTypeTable();

inline const flatbuffers::TypeTable *AICMDHostMulticastEntryTableTypeTable();

inline const flatbuffers::TypeTable *AICMDThreadDescriptorTypeTable();

inline const flatbuffers::TypeTable *AICMDConstantMappingTypeTable();

inline const flatbuffers::TypeTable *QNNConfigDefTypeTable();

inline const flatbuffers::TypeTable *networkHeapBehaviorDefTypeTable();

inline const flatbuffers::TypeTable *NonZeroRegionTypeTable();

inline const flatbuffers::TypeTable *MetadataTypeTable();

enum AICHardwareVersion : int64_t {
  AICHardwareVersion_AIC_HW_VER_1_0 = 65536LL,
  AICHardwareVersion_AIC_HW_VER_2_0 = 131072LL,
  AICHardwareVersion_MIN = AICHardwareVersion_AIC_HW_VER_1_0,
  AICHardwareVersion_MAX = AICHardwareVersion_AIC_HW_VER_2_0
};

inline const AICHardwareVersion (&EnumValuesAICHardwareVersion())[2] {
  static const AICHardwareVersion values[] = {
    AICHardwareVersion_AIC_HW_VER_1_0,
    AICHardwareVersion_AIC_HW_VER_2_0
  };
  return values;
}

inline const char *EnumNameAICHardwareVersion(AICHardwareVersion e) {
  switch (e) {
    case AICHardwareVersion_AIC_HW_VER_1_0: return "AIC_HW_VER_1_0";
    case AICHardwareVersion_AIC_HW_VER_2_0: return "AIC_HW_VER_2_0";
    default: return "";
  }
}

enum AICMDSemaphoreOpcode : int8_t {
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP = 0,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdINIT = 1,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdINC = 2,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdDEC = 3,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITEQ = 4,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITGE = 5,
  AICMDSemaphoreOpcode_AICMDSemaphoreCmdP = 6,
  AICMDSemaphoreOpcode_MIN = AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP,
  AICMDSemaphoreOpcode_MAX = AICMDSemaphoreOpcode_AICMDSemaphoreCmdP
};

inline const AICMDSemaphoreOpcode (&EnumValuesAICMDSemaphoreOpcode())[7] {
  static const AICMDSemaphoreOpcode values[] = {
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP,
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdINIT,
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdINC,
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdDEC,
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITEQ,
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdWAITGE,
    AICMDSemaphoreOpcode_AICMDSemaphoreCmdP
  };
  return values;
}

inline const char * const *EnumNamesAICMDSemaphoreOpcode() {
  static const char * const names[8] = {
    "AICMDSemaphoreCmdNOP",
    "AICMDSemaphoreCmdINIT",
    "AICMDSemaphoreCmdINC",
    "AICMDSemaphoreCmdDEC",
    "AICMDSemaphoreCmdWAITEQ",
    "AICMDSemaphoreCmdWAITGE",
    "AICMDSemaphoreCmdP",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDSemaphoreOpcode(AICMDSemaphoreOpcode e) {
  if (flatbuffers::IsOutRange(e, AICMDSemaphoreOpcode_AICMDSemaphoreCmdNOP, AICMDSemaphoreOpcode_AICMDSemaphoreCmdP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDSemaphoreOpcode()[index];
}

enum AICMDSemaphoreSync : int8_t {
  AICMDSemaphoreSync_AICMDSemaphoreSyncPost = 0,
  AICMDSemaphoreSync_AICMDSemaphoreSyncPre = 1,
  AICMDSemaphoreSync_MIN = AICMDSemaphoreSync_AICMDSemaphoreSyncPost,
  AICMDSemaphoreSync_MAX = AICMDSemaphoreSync_AICMDSemaphoreSyncPre
};

inline const AICMDSemaphoreSync (&EnumValuesAICMDSemaphoreSync())[2] {
  static const AICMDSemaphoreSync values[] = {
    AICMDSemaphoreSync_AICMDSemaphoreSyncPost,
    AICMDSemaphoreSync_AICMDSemaphoreSyncPre
  };
  return values;
}

inline const char * const *EnumNamesAICMDSemaphoreSync() {
  static const char * const names[3] = {
    "AICMDSemaphoreSyncPost",
    "AICMDSemaphoreSyncPre",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDSemaphoreSync(AICMDSemaphoreSync e) {
  if (flatbuffers::IsOutRange(e, AICMDSemaphoreSync_AICMDSemaphoreSyncPost, AICMDSemaphoreSync_AICMDSemaphoreSyncPre)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDSemaphoreSync()[index];
}

enum AICMDDoorbellOpSize : int8_t {
  AICMDDoorbellOpSize_AICMDDoorballOpSize8 = 0,
  AICMDDoorbellOpSize_AICMDDoorballOpSize16 = 1,
  AICMDDoorbellOpSize_AICMDDoorballOpSize32 = 2,
  AICMDDoorbellOpSize_MIN = AICMDDoorbellOpSize_AICMDDoorballOpSize8,
  AICMDDoorbellOpSize_MAX = AICMDDoorbellOpSize_AICMDDoorballOpSize32
};

inline const AICMDDoorbellOpSize (&EnumValuesAICMDDoorbellOpSize())[3] {
  static const AICMDDoorbellOpSize values[] = {
    AICMDDoorbellOpSize_AICMDDoorballOpSize8,
    AICMDDoorbellOpSize_AICMDDoorballOpSize16,
    AICMDDoorbellOpSize_AICMDDoorballOpSize32
  };
  return values;
}

inline const char * const *EnumNamesAICMDDoorbellOpSize() {
  static const char * const names[4] = {
    "AICMDDoorballOpSize8",
    "AICMDDoorballOpSize16",
    "AICMDDoorballOpSize32",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDDoorbellOpSize(AICMDDoorbellOpSize e) {
  if (flatbuffers::IsOutRange(e, AICMDDoorbellOpSize_AICMDDoorballOpSize8, AICMDDoorbellOpSize_AICMDDoorballOpSize32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDDoorbellOpSize()[index];
}

enum AICMDDMAEntryAddrSpace : int8_t {
  AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC = 0,
  AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDR = 1,
  AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDRDynamicShared = 2,
  AICMDDMAEntryAddrSpace_MIN = AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC,
  AICMDDMAEntryAddrSpace_MAX = AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDRDynamicShared
};

inline const AICMDDMAEntryAddrSpace (&EnumValuesAICMDDMAEntryAddrSpace())[3] {
  static const AICMDDMAEntryAddrSpace values[] = {
    AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC,
    AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDR,
    AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDRDynamicShared
  };
  return values;
}

inline const char * const *EnumNamesAICMDDMAEntryAddrSpace() {
  static const char * const names[4] = {
    "AICMDDMAAddrSpaceMC",
    "AICMDDMAAddrSpaceDDR",
    "AICMDDMAAddrSpaceDDRDynamicShared",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDDMAEntryAddrSpace(AICMDDMAEntryAddrSpace e) {
  if (flatbuffers::IsOutRange(e, AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceMC, AICMDDMAEntryAddrSpace_AICMDDMAAddrSpaceDDRDynamicShared)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDDMAEntryAddrSpace()[index];
}

enum AICMDDMADirection : int8_t {
  AICMDDMADirection_AICMDDMAIn = 0,
  AICMDDMADirection_AICMDDMAOut = 1,
  AICMDDMADirection_MIN = AICMDDMADirection_AICMDDMAIn,
  AICMDDMADirection_MAX = AICMDDMADirection_AICMDDMAOut
};

inline const AICMDDMADirection (&EnumValuesAICMDDMADirection())[2] {
  static const AICMDDMADirection values[] = {
    AICMDDMADirection_AICMDDMAIn,
    AICMDDMADirection_AICMDDMAOut
  };
  return values;
}

inline const char * const *EnumNamesAICMDDMADirection() {
  static const char * const names[3] = {
    "AICMDDMAIn",
    "AICMDDMAOut",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDDMADirection(AICMDDMADirection e) {
  if (flatbuffers::IsOutRange(e, AICMDDMADirection_AICMDDMAIn, AICMDDMADirection_AICMDDMAOut)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDDMADirection()[index];
}

enum AICMDPortType : int8_t {
  AICMDPortType_AICMDPortUserIO = 0,
  AICMDPortType_AICMDPortP2P = 1,
  AICMDPortType_AICMDPortMQTH = 2,
  AICMDPortType_MIN = AICMDPortType_AICMDPortUserIO,
  AICMDPortType_MAX = AICMDPortType_AICMDPortMQTH
};

inline const AICMDPortType (&EnumValuesAICMDPortType())[3] {
  static const AICMDPortType values[] = {
    AICMDPortType_AICMDPortUserIO,
    AICMDPortType_AICMDPortP2P,
    AICMDPortType_AICMDPortMQTH
  };
  return values;
}

inline const char * const *EnumNamesAICMDPortType() {
  static const char * const names[4] = {
    "AICMDPortUserIO",
    "AICMDPortP2P",
    "AICMDPortMQTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDPortType(AICMDPortType e) {
  if (flatbuffers::IsOutRange(e, AICMDPortType_AICMDPortUserIO, AICMDPortType_AICMDPortMQTH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDPortType()[index];
}

enum AICMDDMAReserved : uint32_t {
  AICMDDMAReserved_AICMDDMABufNumNone = 65535,
  AICMDDMAReserved_AICMDDMATransactionIdNone = 4294967295,
  AICMDDMAReserved_MIN = AICMDDMAReserved_AICMDDMABufNumNone,
  AICMDDMAReserved_MAX = AICMDDMAReserved_AICMDDMATransactionIdNone
};

inline const AICMDDMAReserved (&EnumValuesAICMDDMAReserved())[2] {
  static const AICMDDMAReserved values[] = {
    AICMDDMAReserved_AICMDDMABufNumNone,
    AICMDDMAReserved_AICMDDMATransactionIdNone
  };
  return values;
}

inline const char *EnumNameAICMDDMAReserved(AICMDDMAReserved e) {
  switch (e) {
    case AICMDDMAReserved_AICMDDMABufNumNone: return "AICMDDMABufNumNone";
    case AICMDDMAReserved_AICMDDMATransactionIdNone: return "AICMDDMATransactionIdNone";
    default: return "";
  }
}

enum AICMDMulticastEntryAddrSpace : int8_t {
  AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM = 0,
  AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM = 1,
  AICMDMulticastEntryAddrSpace_MIN = AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM,
  AICMDMulticastEntryAddrSpace_MAX = AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM
};

inline const AICMDMulticastEntryAddrSpace (&EnumValuesAICMDMulticastEntryAddrSpace())[2] {
  static const AICMDMulticastEntryAddrSpace values[] = {
    AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM,
    AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM
  };
  return values;
}

inline const char * const *EnumNamesAICMDMulticastEntryAddrSpace() {
  static const char * const names[3] = {
    "AICMDAddrSpaceL2TCM",
    "AICMDAddrSpaceVTCM",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDMulticastEntryAddrSpace(AICMDMulticastEntryAddrSpace e) {
  if (flatbuffers::IsOutRange(e, AICMDMulticastEntryAddrSpace_AICMDAddrSpaceL2TCM, AICMDMulticastEntryAddrSpace_AICMDAddrSpaceVTCM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAICMDMulticastEntryAddrSpace()[index];
}

enum AICMDThreadType : int8_t {
  AICMDThreadType_AICMDThreadHMX = 1,
  AICMDThreadType_AICMDThreadHVX = 2,
  AICMDThreadType_MIN = AICMDThreadType_AICMDThreadHMX,
  AICMDThreadType_MAX = AICMDThreadType_AICMDThreadHVX
};

inline const AICMDThreadType (&EnumValuesAICMDThreadType())[2] {
  static const AICMDThreadType values[] = {
    AICMDThreadType_AICMDThreadHMX,
    AICMDThreadType_AICMDThreadHVX
  };
  return values;
}

inline const char * const *EnumNamesAICMDThreadType() {
  static const char * const names[3] = {
    "AICMDThreadHMX",
    "AICMDThreadHVX",
    nullptr
  };
  return names;
}

inline const char *EnumNameAICMDThreadType(AICMDThreadType e) {
  if (flatbuffers::IsOutRange(e, AICMDThreadType_AICMDThreadHMX, AICMDThreadType_AICMDThreadHVX)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AICMDThreadType_AICMDThreadHMX);
  return EnumNamesAICMDThreadType()[index];
}

enum cacheableConstants : int8_t {
  cacheableConstants_CACHE_DISABLED = 1,
  cacheableConstants_CACHE_ENABLED = 2,
  cacheableConstants_MIN = cacheableConstants_CACHE_DISABLED,
  cacheableConstants_MAX = cacheableConstants_CACHE_ENABLED
};

inline const cacheableConstants (&EnumValuescacheableConstants())[2] {
  static const cacheableConstants values[] = {
    cacheableConstants_CACHE_DISABLED,
    cacheableConstants_CACHE_ENABLED
  };
  return values;
}

inline const char * const *EnumNamescacheableConstants() {
  static const char * const names[3] = {
    "CACHE_DISABLED",
    "CACHE_ENABLED",
    nullptr
  };
  return names;
}

inline const char *EnumNamecacheableConstants(cacheableConstants e) {
  if (flatbuffers::IsOutRange(e, cacheableConstants_CACHE_DISABLED, cacheableConstants_CACHE_ENABLED)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(cacheableConstants_CACHE_DISABLED);
  return EnumNamescacheableConstants()[index];
}

enum networkDeactivateAction : int8_t {
  networkDeactivateAction_freeNetworkHeap = 1,
  networkDeactivateAction_preserveNetworkHeap = 2,
  networkDeactivateAction_MIN = networkDeactivateAction_freeNetworkHeap,
  networkDeactivateAction_MAX = networkDeactivateAction_preserveNetworkHeap
};

inline const networkDeactivateAction (&EnumValuesnetworkDeactivateAction())[2] {
  static const networkDeactivateAction values[] = {
    networkDeactivateAction_freeNetworkHeap,
    networkDeactivateAction_preserveNetworkHeap
  };
  return values;
}

inline const char * const *EnumNamesnetworkDeactivateAction() {
  static const char * const names[3] = {
    "freeNetworkHeap",
    "preserveNetworkHeap",
    nullptr
  };
  return names;
}

inline const char *EnumNamenetworkDeactivateAction(networkDeactivateAction e) {
  if (flatbuffers::IsOutRange(e, networkDeactivateAction_freeNetworkHeap, networkDeactivateAction_preserveNetworkHeap)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(networkDeactivateAction_freeNetworkHeap);
  return EnumNamesnetworkDeactivateAction()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) AICMDPortEntry FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t portId_;
  int8_t portType_;
  int8_t padding0__;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDPortEntryTypeTable();
  }
  AICMDPortEntry()
      : portId_(0),
        portType_(0),
        padding0__(0) {
    (void)padding0__;
  }
  AICMDPortEntry(uint16_t _portId, AicMetadataFlat::AICMDPortType _portType)
      : portId_(flatbuffers::EndianScalar(_portId)),
        portType_(flatbuffers::EndianScalar(static_cast<int8_t>(_portType))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t portId() const {
    return flatbuffers::EndianScalar(portId_);
  }
  AicMetadataFlat::AICMDPortType portType() const {
    return static_cast<AicMetadataFlat::AICMDPortType>(flatbuffers::EndianScalar(portType_));
  }
};
FLATBUFFERS_STRUCT_END(AICMDPortEntry, 4);

struct AICMDSemaphoreOpT : public flatbuffers::NativeTable {
  typedef AICMDSemaphoreOp TableType;
  uint16_t semNum = 0;
  uint16_t semValue = 0;
  uint8_t semOp = 0;
  uint8_t preOrPost = 0;
  uint8_t inSyncFence = 0;
  uint8_t outSyncFence = 0;
};

struct AICMDSemaphoreOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDSemaphoreOpT NativeTableType;
  typedef AICMDSemaphoreOpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDSemaphoreOpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMNUM = 4,
    VT_SEMVALUE = 6,
    VT_SEMOP = 8,
    VT_PREORPOST = 10,
    VT_INSYNCFENCE = 12,
    VT_OUTSYNCFENCE = 14
  };
  uint16_t semNum() const {
    return GetField<uint16_t>(VT_SEMNUM, 0);
  }
  uint16_t semValue() const {
    return GetField<uint16_t>(VT_SEMVALUE, 0);
  }
  uint8_t semOp() const {
    return GetField<uint8_t>(VT_SEMOP, 0);
  }
  uint8_t preOrPost() const {
    return GetField<uint8_t>(VT_PREORPOST, 0);
  }
  uint8_t inSyncFence() const {
    return GetField<uint8_t>(VT_INSYNCFENCE, 0);
  }
  uint8_t outSyncFence() const {
    return GetField<uint8_t>(VT_OUTSYNCFENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SEMNUM, 2) &&
           VerifyField<uint16_t>(verifier, VT_SEMVALUE, 2) &&
           VerifyField<uint8_t>(verifier, VT_SEMOP, 1) &&
           VerifyField<uint8_t>(verifier, VT_PREORPOST, 1) &&
           VerifyField<uint8_t>(verifier, VT_INSYNCFENCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTSYNCFENCE, 1) &&
           verifier.EndTable();
  }
  AICMDSemaphoreOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDSemaphoreOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDSemaphoreOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDSemaphoreOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDSemaphoreOpBuilder {
  typedef AICMDSemaphoreOp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_semNum(uint16_t semNum) {
    fbb_.AddElement<uint16_t>(AICMDSemaphoreOp::VT_SEMNUM, semNum, 0);
  }
  void add_semValue(uint16_t semValue) {
    fbb_.AddElement<uint16_t>(AICMDSemaphoreOp::VT_SEMVALUE, semValue, 0);
  }
  void add_semOp(uint8_t semOp) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_SEMOP, semOp, 0);
  }
  void add_preOrPost(uint8_t preOrPost) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_PREORPOST, preOrPost, 0);
  }
  void add_inSyncFence(uint8_t inSyncFence) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_INSYNCFENCE, inSyncFence, 0);
  }
  void add_outSyncFence(uint8_t outSyncFence) {
    fbb_.AddElement<uint8_t>(AICMDSemaphoreOp::VT_OUTSYNCFENCE, outSyncFence, 0);
  }
  explicit AICMDSemaphoreOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDSemaphoreOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDSemaphoreOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDSemaphoreOp> CreateAICMDSemaphoreOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t semNum = 0,
    uint16_t semValue = 0,
    uint8_t semOp = 0,
    uint8_t preOrPost = 0,
    uint8_t inSyncFence = 0,
    uint8_t outSyncFence = 0) {
  AICMDSemaphoreOpBuilder builder_(_fbb);
  builder_.add_semValue(semValue);
  builder_.add_semNum(semNum);
  builder_.add_outSyncFence(outSyncFence);
  builder_.add_inSyncFence(inSyncFence);
  builder_.add_preOrPost(preOrPost);
  builder_.add_semOp(semOp);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDSemaphoreOp> CreateAICMDSemaphoreOp(flatbuffers::FlatBufferBuilder &_fbb, const AICMDSemaphoreOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDDoorbellOpT : public flatbuffers::NativeTable {
  typedef AICMDDoorbellOp TableType;
  uint64_t offset = 0;
  uint32_t data = 0;
  uint16_t mcId = 0;
  uint8_t size = 0;
};

struct AICMDDoorbellOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDDoorbellOpT NativeTableType;
  typedef AICMDDoorbellOpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDDoorbellOpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_DATA = 6,
    VT_MCID = 8,
    VT_SIZE = 10
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint32_t data() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  uint16_t mcId() const {
    return GetField<uint16_t>(VT_MCID, 0);
  }
  uint8_t size() const {
    return GetField<uint8_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_DATA, 4) &&
           VerifyField<uint16_t>(verifier, VT_MCID, 2) &&
           VerifyField<uint8_t>(verifier, VT_SIZE, 1) &&
           verifier.EndTable();
  }
  AICMDDoorbellOpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDDoorbellOpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDDoorbellOp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDoorbellOpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDDoorbellOpBuilder {
  typedef AICMDDoorbellOp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(AICMDDoorbellOp::VT_OFFSET, offset, 0);
  }
  void add_data(uint32_t data) {
    fbb_.AddElement<uint32_t>(AICMDDoorbellOp::VT_DATA, data, 0);
  }
  void add_mcId(uint16_t mcId) {
    fbb_.AddElement<uint16_t>(AICMDDoorbellOp::VT_MCID, mcId, 0);
  }
  void add_size(uint8_t size) {
    fbb_.AddElement<uint8_t>(AICMDDoorbellOp::VT_SIZE, size, 0);
  }
  explicit AICMDDoorbellOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDDoorbellOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDDoorbellOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDDoorbellOp> CreateAICMDDoorbellOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0,
    uint32_t data = 0,
    uint16_t mcId = 0,
    uint8_t size = 0) {
  AICMDDoorbellOpBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_data(data);
  builder_.add_mcId(mcId);
  builder_.add_size(size);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDDoorbellOp> CreateAICMDDoorbellOp(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDoorbellOpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDDMARequestT : public flatbuffers::NativeTable {
  typedef AICMDDMARequest TableType;
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDSemaphoreOpT>> semaphoreOps{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDDoorbellOpT>> doorbellOps{};
  uint64_t hostOffset = 0;
  uint64_t devOffset = 0;
  uint32_t size = 0;
  uint16_t num = 0;
  uint16_t mcId = 0;
  uint8_t devAddrSpace = 0;
  uint8_t inOut = 0;
  uint16_t portId = 0;
  uint32_t transactionId = 0;
  AICMDDMARequestT() = default;
  AICMDDMARequestT(const AICMDDMARequestT &o);
  AICMDDMARequestT(AICMDDMARequestT&&) FLATBUFFERS_NOEXCEPT = default;
  AICMDDMARequestT &operator=(AICMDDMARequestT o) FLATBUFFERS_NOEXCEPT;
};

struct AICMDDMARequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDDMARequestT NativeTableType;
  typedef AICMDDMARequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDDMARequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEMAPHOREOPS = 4,
    VT_DOORBELLOPS = 6,
    VT_HOSTOFFSET = 8,
    VT_DEVOFFSET = 10,
    VT_SIZE = 12,
    VT_NUM = 14,
    VT_MCID = 16,
    VT_DEVADDRSPACE = 18,
    VT_INOUT = 20,
    VT_PORTID = 22,
    VT_TRANSACTIONID = 24
  };
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>> *semaphoreOps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>> *>(VT_SEMAPHOREOPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>> *doorbellOps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>> *>(VT_DOORBELLOPS);
  }
  uint64_t hostOffset() const {
    return GetField<uint64_t>(VT_HOSTOFFSET, 0);
  }
  uint64_t devOffset() const {
    return GetField<uint64_t>(VT_DEVOFFSET, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint16_t num() const {
    return GetField<uint16_t>(VT_NUM, 0);
  }
  uint16_t mcId() const {
    return GetField<uint16_t>(VT_MCID, 0);
  }
  uint8_t devAddrSpace() const {
    return GetField<uint8_t>(VT_DEVADDRSPACE, 0);
  }
  uint8_t inOut() const {
    return GetField<uint8_t>(VT_INOUT, 0);
  }
  uint16_t portId() const {
    return GetField<uint16_t>(VT_PORTID, 0);
  }
  uint32_t transactionId() const {
    return GetField<uint32_t>(VT_TRANSACTIONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEMAPHOREOPS) &&
           verifier.VerifyVector(semaphoreOps()) &&
           verifier.VerifyVectorOfTables(semaphoreOps()) &&
           VerifyOffset(verifier, VT_DOORBELLOPS) &&
           verifier.VerifyVector(doorbellOps()) &&
           verifier.VerifyVectorOfTables(doorbellOps()) &&
           VerifyField<uint64_t>(verifier, VT_HOSTOFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_DEVOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_NUM, 2) &&
           VerifyField<uint16_t>(verifier, VT_MCID, 2) &&
           VerifyField<uint8_t>(verifier, VT_DEVADDRSPACE, 1) &&
           VerifyField<uint8_t>(verifier, VT_INOUT, 1) &&
           VerifyField<uint16_t>(verifier, VT_PORTID, 2) &&
           VerifyField<uint32_t>(verifier, VT_TRANSACTIONID, 4) &&
           verifier.EndTable();
  }
  AICMDDMARequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDDMARequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDDMARequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDMARequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDDMARequestBuilder {
  typedef AICMDDMARequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_semaphoreOps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>> semaphoreOps) {
    fbb_.AddOffset(AICMDDMARequest::VT_SEMAPHOREOPS, semaphoreOps);
  }
  void add_doorbellOps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>> doorbellOps) {
    fbb_.AddOffset(AICMDDMARequest::VT_DOORBELLOPS, doorbellOps);
  }
  void add_hostOffset(uint64_t hostOffset) {
    fbb_.AddElement<uint64_t>(AICMDDMARequest::VT_HOSTOFFSET, hostOffset, 0);
  }
  void add_devOffset(uint64_t devOffset) {
    fbb_.AddElement<uint64_t>(AICMDDMARequest::VT_DEVOFFSET, devOffset, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDDMARequest::VT_SIZE, size, 0);
  }
  void add_num(uint16_t num) {
    fbb_.AddElement<uint16_t>(AICMDDMARequest::VT_NUM, num, 0);
  }
  void add_mcId(uint16_t mcId) {
    fbb_.AddElement<uint16_t>(AICMDDMARequest::VT_MCID, mcId, 0);
  }
  void add_devAddrSpace(uint8_t devAddrSpace) {
    fbb_.AddElement<uint8_t>(AICMDDMARequest::VT_DEVADDRSPACE, devAddrSpace, 0);
  }
  void add_inOut(uint8_t inOut) {
    fbb_.AddElement<uint8_t>(AICMDDMARequest::VT_INOUT, inOut, 0);
  }
  void add_portId(uint16_t portId) {
    fbb_.AddElement<uint16_t>(AICMDDMARequest::VT_PORTID, portId, 0);
  }
  void add_transactionId(uint32_t transactionId) {
    fbb_.AddElement<uint32_t>(AICMDDMARequest::VT_TRANSACTIONID, transactionId, 0);
  }
  explicit AICMDDMARequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDDMARequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDDMARequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>> semaphoreOps = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>> doorbellOps = 0,
    uint64_t hostOffset = 0,
    uint64_t devOffset = 0,
    uint32_t size = 0,
    uint16_t num = 0,
    uint16_t mcId = 0,
    uint8_t devAddrSpace = 0,
    uint8_t inOut = 0,
    uint16_t portId = 0,
    uint32_t transactionId = 0) {
  AICMDDMARequestBuilder builder_(_fbb);
  builder_.add_devOffset(devOffset);
  builder_.add_hostOffset(hostOffset);
  builder_.add_transactionId(transactionId);
  builder_.add_size(size);
  builder_.add_doorbellOps(doorbellOps);
  builder_.add_semaphoreOps(semaphoreOps);
  builder_.add_portId(portId);
  builder_.add_mcId(mcId);
  builder_.add_num(num);
  builder_.add_inOut(inOut);
  builder_.add_devAddrSpace(devAddrSpace);
  return builder_.Finish();
}

inline flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>> *semaphoreOps = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>> *doorbellOps = nullptr,
    uint64_t hostOffset = 0,
    uint64_t devOffset = 0,
    uint32_t size = 0,
    uint16_t num = 0,
    uint16_t mcId = 0,
    uint8_t devAddrSpace = 0,
    uint8_t inOut = 0,
    uint16_t portId = 0,
    uint32_t transactionId = 0) {
  auto semaphoreOps__ = semaphoreOps ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>>(*semaphoreOps) : 0;
  auto doorbellOps__ = doorbellOps ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>>(*doorbellOps) : 0;
  return AicMetadataFlat::CreateAICMDDMARequest(
      _fbb,
      semaphoreOps__,
      doorbellOps__,
      hostOffset,
      devOffset,
      size,
      num,
      mcId,
      devAddrSpace,
      inOut,
      portId,
      transactionId);
}

flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequest(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDMARequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDNSPMulticastEntryT : public flatbuffers::NativeTable {
  typedef AICMDNSPMulticastEntry TableType;
  uint64_t baseAddrOffset = 0;
  uint32_t mask = 0;
  uint32_t size = 0;
  uint8_t addrSpace = 0;
  uint8_t dynamic = 0;
};

struct AICMDNSPMulticastEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDNSPMulticastEntryT NativeTableType;
  typedef AICMDNSPMulticastEntryBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDNSPMulticastEntryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASEADDROFFSET = 4,
    VT_MASK = 6,
    VT_SIZE = 8,
    VT_ADDRSPACE = 10,
    VT_DYNAMIC = 12
  };
  uint64_t baseAddrOffset() const {
    return GetField<uint64_t>(VT_BASEADDROFFSET, 0);
  }
  uint32_t mask() const {
    return GetField<uint32_t>(VT_MASK, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint8_t addrSpace() const {
    return GetField<uint8_t>(VT_ADDRSPACE, 0);
  }
  uint8_t dynamic() const {
    return GetField<uint8_t>(VT_DYNAMIC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BASEADDROFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_MASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ADDRSPACE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC, 1) &&
           verifier.EndTable();
  }
  AICMDNSPMulticastEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDNSPMulticastEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDNSPMulticastEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDNSPMulticastEntryBuilder {
  typedef AICMDNSPMulticastEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseAddrOffset(uint64_t baseAddrOffset) {
    fbb_.AddElement<uint64_t>(AICMDNSPMulticastEntry::VT_BASEADDROFFSET, baseAddrOffset, 0);
  }
  void add_mask(uint32_t mask) {
    fbb_.AddElement<uint32_t>(AICMDNSPMulticastEntry::VT_MASK, mask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDNSPMulticastEntry::VT_SIZE, size, 0);
  }
  void add_addrSpace(uint8_t addrSpace) {
    fbb_.AddElement<uint8_t>(AICMDNSPMulticastEntry::VT_ADDRSPACE, addrSpace, 0);
  }
  void add_dynamic(uint8_t dynamic) {
    fbb_.AddElement<uint8_t>(AICMDNSPMulticastEntry::VT_DYNAMIC, dynamic, 0);
  }
  explicit AICMDNSPMulticastEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDNSPMulticastEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDNSPMulticastEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDNSPMulticastEntry> CreateAICMDNSPMulticastEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t baseAddrOffset = 0,
    uint32_t mask = 0,
    uint32_t size = 0,
    uint8_t addrSpace = 0,
    uint8_t dynamic = 0) {
  AICMDNSPMulticastEntryBuilder builder_(_fbb);
  builder_.add_baseAddrOffset(baseAddrOffset);
  builder_.add_size(size);
  builder_.add_mask(mask);
  builder_.add_dynamic(dynamic);
  builder_.add_addrSpace(addrSpace);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDNSPMulticastEntry> CreateAICMDNSPMulticastEntry(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDNSPMulticastEntryTableT : public flatbuffers::NativeTable {
  typedef AICMDNSPMulticastEntryTable TableType;
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryT>> multicastEntries{};
  AICMDNSPMulticastEntryTableT() = default;
  AICMDNSPMulticastEntryTableT(const AICMDNSPMulticastEntryTableT &o);
  AICMDNSPMulticastEntryTableT(AICMDNSPMulticastEntryTableT&&) FLATBUFFERS_NOEXCEPT = default;
  AICMDNSPMulticastEntryTableT &operator=(AICMDNSPMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT;
};

struct AICMDNSPMulticastEntryTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDNSPMulticastEntryTableT NativeTableType;
  typedef AICMDNSPMulticastEntryTableBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDNSPMulticastEntryTableTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTICASTENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>> *multicastEntries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>> *>(VT_MULTICASTENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTICASTENTRIES) &&
           verifier.VerifyVector(multicastEntries()) &&
           verifier.VerifyVectorOfTables(multicastEntries()) &&
           verifier.EndTable();
  }
  AICMDNSPMulticastEntryTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDNSPMulticastEntryTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDNSPMulticastEntryTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDNSPMulticastEntryTableBuilder {
  typedef AICMDNSPMulticastEntryTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multicastEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>> multicastEntries) {
    fbb_.AddOffset(AICMDNSPMulticastEntryTable::VT_MULTICASTENTRIES, multicastEntries);
  }
  explicit AICMDNSPMulticastEntryTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDNSPMulticastEntryTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDNSPMulticastEntryTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable> CreateAICMDNSPMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>> multicastEntries = 0) {
  AICMDNSPMulticastEntryTableBuilder builder_(_fbb);
  builder_.add_multicastEntries(multicastEntries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable> CreateAICMDNSPMulticastEntryTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>> *multicastEntries = nullptr) {
  auto multicastEntries__ = multicastEntries ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>>(*multicastEntries) : 0;
  return AicMetadataFlat::CreateAICMDNSPMulticastEntryTable(
      _fbb,
      multicastEntries__);
}

flatbuffers::Offset<AICMDNSPMulticastEntryTable> CreateAICMDNSPMulticastEntryTable(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDHostMulticastEntryT : public flatbuffers::NativeTable {
  typedef AICMDHostMulticastEntry TableType;
  uint32_t mask = 0;
  uint32_t size = 0;
};

struct AICMDHostMulticastEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDHostMulticastEntryT NativeTableType;
  typedef AICMDHostMulticastEntryBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDHostMulticastEntryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MASK = 4,
    VT_SIZE = 6
  };
  uint32_t mask() const {
    return GetField<uint32_t>(VT_MASK, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  AICMDHostMulticastEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDHostMulticastEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDHostMulticastEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDHostMulticastEntryBuilder {
  typedef AICMDHostMulticastEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mask(uint32_t mask) {
    fbb_.AddElement<uint32_t>(AICMDHostMulticastEntry::VT_MASK, mask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDHostMulticastEntry::VT_SIZE, size, 0);
  }
  explicit AICMDHostMulticastEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDHostMulticastEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDHostMulticastEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDHostMulticastEntry> CreateAICMDHostMulticastEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mask = 0,
    uint32_t size = 0) {
  AICMDHostMulticastEntryBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_mask(mask);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDHostMulticastEntry> CreateAICMDHostMulticastEntry(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDHostMulticastEntryTableT : public flatbuffers::NativeTable {
  typedef AICMDHostMulticastEntryTable TableType;
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryT>> multicastEntries{};
  AICMDHostMulticastEntryTableT() = default;
  AICMDHostMulticastEntryTableT(const AICMDHostMulticastEntryTableT &o);
  AICMDHostMulticastEntryTableT(AICMDHostMulticastEntryTableT&&) FLATBUFFERS_NOEXCEPT = default;
  AICMDHostMulticastEntryTableT &operator=(AICMDHostMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT;
};

struct AICMDHostMulticastEntryTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDHostMulticastEntryTableT NativeTableType;
  typedef AICMDHostMulticastEntryTableBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDHostMulticastEntryTableTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTICASTENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>> *multicastEntries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>> *>(VT_MULTICASTENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTICASTENTRIES) &&
           verifier.VerifyVector(multicastEntries()) &&
           verifier.VerifyVectorOfTables(multicastEntries()) &&
           verifier.EndTable();
  }
  AICMDHostMulticastEntryTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDHostMulticastEntryTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDHostMulticastEntryTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDHostMulticastEntryTableBuilder {
  typedef AICMDHostMulticastEntryTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multicastEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>> multicastEntries) {
    fbb_.AddOffset(AICMDHostMulticastEntryTable::VT_MULTICASTENTRIES, multicastEntries);
  }
  explicit AICMDHostMulticastEntryTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDHostMulticastEntryTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDHostMulticastEntryTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDHostMulticastEntryTable> CreateAICMDHostMulticastEntryTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>> multicastEntries = 0) {
  AICMDHostMulticastEntryTableBuilder builder_(_fbb);
  builder_.add_multicastEntries(multicastEntries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AICMDHostMulticastEntryTable> CreateAICMDHostMulticastEntryTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>> *multicastEntries = nullptr) {
  auto multicastEntries__ = multicastEntries ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>>(*multicastEntries) : 0;
  return AicMetadataFlat::CreateAICMDHostMulticastEntryTable(
      _fbb,
      multicastEntries__);
}

flatbuffers::Offset<AICMDHostMulticastEntryTable> CreateAICMDHostMulticastEntryTable(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDThreadDescriptorT : public flatbuffers::NativeTable {
  typedef AICMDThreadDescriptor TableType;
  uint64_t entryPoint = 0;
  uint8_t typeMask = 0;
};

struct AICMDThreadDescriptor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDThreadDescriptorT NativeTableType;
  typedef AICMDThreadDescriptorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDThreadDescriptorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRYPOINT = 4,
    VT_TYPEMASK = 6
  };
  uint64_t entryPoint() const {
    return GetField<uint64_t>(VT_ENTRYPOINT, 0);
  }
  uint8_t typeMask() const {
    return GetField<uint8_t>(VT_TYPEMASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ENTRYPOINT, 8) &&
           VerifyField<uint8_t>(verifier, VT_TYPEMASK, 1) &&
           verifier.EndTable();
  }
  AICMDThreadDescriptorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDThreadDescriptorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDThreadDescriptor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDThreadDescriptorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDThreadDescriptorBuilder {
  typedef AICMDThreadDescriptor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entryPoint(uint64_t entryPoint) {
    fbb_.AddElement<uint64_t>(AICMDThreadDescriptor::VT_ENTRYPOINT, entryPoint, 0);
  }
  void add_typeMask(uint8_t typeMask) {
    fbb_.AddElement<uint8_t>(AICMDThreadDescriptor::VT_TYPEMASK, typeMask, 0);
  }
  explicit AICMDThreadDescriptorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDThreadDescriptor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDThreadDescriptor>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDThreadDescriptor> CreateAICMDThreadDescriptor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t entryPoint = 0,
    uint8_t typeMask = 0) {
  AICMDThreadDescriptorBuilder builder_(_fbb);
  builder_.add_entryPoint(entryPoint);
  builder_.add_typeMask(typeMask);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDThreadDescriptor> CreateAICMDThreadDescriptor(flatbuffers::FlatBufferBuilder &_fbb, const AICMDThreadDescriptorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AICMDConstantMappingT : public flatbuffers::NativeTable {
  typedef AICMDConstantMapping TableType;
  uint64_t constantDataBaseOffset = 0;
  uint32_t coreMask = 0;
  uint32_t size = 0;
};

struct AICMDConstantMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AICMDConstantMappingT NativeTableType;
  typedef AICMDConstantMappingBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AICMDConstantMappingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTANTDATABASEOFFSET = 4,
    VT_COREMASK = 6,
    VT_SIZE = 8
  };
  uint64_t constantDataBaseOffset() const {
    return GetField<uint64_t>(VT_CONSTANTDATABASEOFFSET, 0);
  }
  uint32_t coreMask() const {
    return GetField<uint32_t>(VT_COREMASK, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CONSTANTDATABASEOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_COREMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  AICMDConstantMappingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AICMDConstantMappingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AICMDConstantMapping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDConstantMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AICMDConstantMappingBuilder {
  typedef AICMDConstantMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constantDataBaseOffset(uint64_t constantDataBaseOffset) {
    fbb_.AddElement<uint64_t>(AICMDConstantMapping::VT_CONSTANTDATABASEOFFSET, constantDataBaseOffset, 0);
  }
  void add_coreMask(uint32_t coreMask) {
    fbb_.AddElement<uint32_t>(AICMDConstantMapping::VT_COREMASK, coreMask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(AICMDConstantMapping::VT_SIZE, size, 0);
  }
  explicit AICMDConstantMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AICMDConstantMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AICMDConstantMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<AICMDConstantMapping> CreateAICMDConstantMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t constantDataBaseOffset = 0,
    uint32_t coreMask = 0,
    uint32_t size = 0) {
  AICMDConstantMappingBuilder builder_(_fbb);
  builder_.add_constantDataBaseOffset(constantDataBaseOffset);
  builder_.add_size(size);
  builder_.add_coreMask(coreMask);
  return builder_.Finish();
}

flatbuffers::Offset<AICMDConstantMapping> CreateAICMDConstantMapping(flatbuffers::FlatBufferBuilder &_fbb, const AICMDConstantMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QNNConfigDefT : public flatbuffers::NativeTable {
  typedef QNNConfigDef TableType;
  AicMetadataFlat::cacheableConstants Constants = AicMetadataFlat::cacheableConstants_CACHE_DISABLED;
};

struct QNNConfigDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QNNConfigDefT NativeTableType;
  typedef QNNConfigDefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QNNConfigDefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTANTS = 4
  };
  AicMetadataFlat::cacheableConstants Constants() const {
    return static_cast<AicMetadataFlat::cacheableConstants>(GetField<int8_t>(VT_CONSTANTS, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CONSTANTS, 1) &&
           verifier.EndTable();
  }
  QNNConfigDefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QNNConfigDefT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QNNConfigDef> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QNNConfigDefT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QNNConfigDefBuilder {
  typedef QNNConfigDef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Constants(AicMetadataFlat::cacheableConstants Constants) {
    fbb_.AddElement<int8_t>(QNNConfigDef::VT_CONSTANTS, static_cast<int8_t>(Constants), 1);
  }
  explicit QNNConfigDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QNNConfigDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QNNConfigDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<QNNConfigDef> CreateQNNConfigDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    AicMetadataFlat::cacheableConstants Constants = AicMetadataFlat::cacheableConstants_CACHE_DISABLED) {
  QNNConfigDefBuilder builder_(_fbb);
  builder_.add_Constants(Constants);
  return builder_.Finish();
}

flatbuffers::Offset<QNNConfigDef> CreateQNNConfigDef(flatbuffers::FlatBufferBuilder &_fbb, const QNNConfigDefT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct networkHeapBehaviorDefT : public flatbuffers::NativeTable {
  typedef networkHeapBehaviorDef TableType;
  AicMetadataFlat::networkDeactivateAction onNetworkDeactivate = AicMetadataFlat::networkDeactivateAction_freeNetworkHeap;
};

struct networkHeapBehaviorDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef networkHeapBehaviorDefT NativeTableType;
  typedef networkHeapBehaviorDefBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return networkHeapBehaviorDefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ONNETWORKDEACTIVATE = 4
  };
  AicMetadataFlat::networkDeactivateAction onNetworkDeactivate() const {
    return static_cast<AicMetadataFlat::networkDeactivateAction>(GetField<int8_t>(VT_ONNETWORKDEACTIVATE, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ONNETWORKDEACTIVATE, 1) &&
           verifier.EndTable();
  }
  networkHeapBehaviorDefT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(networkHeapBehaviorDefT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<networkHeapBehaviorDef> Pack(flatbuffers::FlatBufferBuilder &_fbb, const networkHeapBehaviorDefT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct networkHeapBehaviorDefBuilder {
  typedef networkHeapBehaviorDef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_onNetworkDeactivate(AicMetadataFlat::networkDeactivateAction onNetworkDeactivate) {
    fbb_.AddElement<int8_t>(networkHeapBehaviorDef::VT_ONNETWORKDEACTIVATE, static_cast<int8_t>(onNetworkDeactivate), 1);
  }
  explicit networkHeapBehaviorDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<networkHeapBehaviorDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<networkHeapBehaviorDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<networkHeapBehaviorDef> CreatenetworkHeapBehaviorDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    AicMetadataFlat::networkDeactivateAction onNetworkDeactivate = AicMetadataFlat::networkDeactivateAction_freeNetworkHeap) {
  networkHeapBehaviorDefBuilder builder_(_fbb);
  builder_.add_onNetworkDeactivate(onNetworkDeactivate);
  return builder_.Finish();
}

flatbuffers::Offset<networkHeapBehaviorDef> CreatenetworkHeapBehaviorDef(flatbuffers::FlatBufferBuilder &_fbb, const networkHeapBehaviorDefT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonZeroRegionT : public flatbuffers::NativeTable {
  typedef NonZeroRegion TableType;
  uint64_t start = 0;
  uint64_t end = 0;
  uint64_t size = 0;
};

struct NonZeroRegion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonZeroRegionT NativeTableType;
  typedef NonZeroRegionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonZeroRegionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_END = 6,
    VT_SIZE = 8
  };
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  uint64_t end() const {
    return GetField<uint64_t>(VT_END, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START, 8) &&
           VerifyField<uint64_t>(verifier, VT_END, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
  NonZeroRegionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonZeroRegionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonZeroRegion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroRegionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonZeroRegionBuilder {
  typedef NonZeroRegion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(NonZeroRegion::VT_START, start, 0);
  }
  void add_end(uint64_t end) {
    fbb_.AddElement<uint64_t>(NonZeroRegion::VT_END, end, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(NonZeroRegion::VT_SIZE, size, 0);
  }
  explicit NonZeroRegionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonZeroRegion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonZeroRegion>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonZeroRegion> CreateNonZeroRegion(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start = 0,
    uint64_t end = 0,
    uint64_t size = 0) {
  NonZeroRegionBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_end(end);
  builder_.add_start(start);
  return builder_.Finish();
}

flatbuffers::Offset<NonZeroRegion> CreateNonZeroRegion(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroRegionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
  typedef Metadata TableType;
  uint16_t versionMajor = 0;
  uint16_t versionMinor = 0;
  std::string networkName{};
  std::vector<std::string> requiredFields{};
  std::vector<uint32_t> semaphoreInitState{};
  std::vector<uint8_t> L2TCMInitState{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDDMARequestT>> dmaRequests{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryTableT>> nspMulticastTables{};
  std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryTableT> hostMulticastTable{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDThreadDescriptorT>> threadDescriptors{};
  std::vector<std::unique_ptr<AicMetadataFlat::AICMDConstantMappingT>> constantMappings{};
  uint64_t staticSharedDDRSize = 0;
  uint64_t dynamicSharedDDRSize = 0;
  uint64_t staticConstantsSize = 0;
  uint64_t dynamicConstantsSize = 0;
  uint64_t exitDoorbellOffset = 0;
  uint32_t l2CachedDDRSize = 0;
  uint32_t L2TCMInitSize = 0;
  uint16_t execContextMajorVersion = 0;
  uint16_t numNSPs = 0;
  uint16_t numSemaphores = 0;
  uint8_t hwVersionMajor = 0;
  uint8_t hwVersionMinor = 0;
  uint8_t staticSharedDDRECCEnabled = 0;
  uint8_t dynamicSharedDDRECCEnabled = 0;
  uint8_t staticConstantsECCEnabled = 0;
  uint8_t dynamicConstantsECCEnabled = 0;
  uint8_t singleVTCMPage = 0;
  uint8_t hasHvxFP = 0;
  uint8_t hasHmxFP = 0;
  uint32_t VTCMSize = 0;
  uint32_t L2TCMSize = 0;
  uint64_t networkHeapSize = 0;
  uint64_t raw_struct_version_length = 0;
  std::unique_ptr<AicMetadataFlat::QNNConfigDefT> QNNConfig{};
  std::vector<AicMetadataFlat::AICMDPortEntry> portTable{};
  std::vector<uint8_t> execContext{};
  std::vector<std::unique_ptr<AicMetadataFlat::NonZeroRegionT>> L2TCMInitStateNonZeroRegions{};
  uint8_t dynamicSharedDDRSupported = 0;
  std::unique_ptr<AicMetadataFlat::networkHeapBehaviorDefT> networkHeapBehavior{};
  MetadataT() = default;
  MetadataT(const MetadataT &o);
  MetadataT(MetadataT&&) FLATBUFFERS_NOEXCEPT = default;
  MetadataT &operator=(MetadataT o) FLATBUFFERS_NOEXCEPT;
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataT NativeTableType;
  typedef MetadataBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MetadataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSIONMAJOR = 4,
    VT_VERSIONMINOR = 6,
    VT_NETWORKNAME = 8,
    VT_REQUIREDFIELDS = 10,
    VT_SEMAPHOREINITSTATE = 12,
    VT_L2TCMINITSTATE = 14,
    VT_DMAREQUESTS = 16,
    VT_NSPMULTICASTTABLES = 18,
    VT_HOSTMULTICASTTABLE = 20,
    VT_THREADDESCRIPTORS = 22,
    VT_CONSTANTMAPPINGS = 24,
    VT_STATICSHAREDDDRSIZE = 26,
    VT_DYNAMICSHAREDDDRSIZE = 28,
    VT_STATICCONSTANTSSIZE = 30,
    VT_DYNAMICCONSTANTSSIZE = 32,
    VT_EXITDOORBELLOFFSET = 34,
    VT_L2CACHEDDDRSIZE = 36,
    VT_L2TCMINITSIZE = 38,
    VT_EXECCONTEXTMAJORVERSION = 40,
    VT_NUMNSPS = 42,
    VT_NUMSEMAPHORES = 44,
    VT_HWVERSIONMAJOR = 46,
    VT_HWVERSIONMINOR = 48,
    VT_STATICSHAREDDDRECCENABLED = 50,
    VT_DYNAMICSHAREDDDRECCENABLED = 52,
    VT_STATICCONSTANTSECCENABLED = 54,
    VT_DYNAMICCONSTANTSECCENABLED = 56,
    VT_SINGLEVTCMPAGE = 58,
    VT_HASHVXFP = 60,
    VT_HASHMXFP = 62,
    VT_VTCMSIZE = 64,
    VT_L2TCMSIZE = 66,
    VT_NETWORKHEAPSIZE = 68,
    VT_RAW_STRUCT_VERSION_LENGTH = 70,
    VT_QNNCONFIG = 72,
    VT_PORTTABLE = 74,
    VT_EXECCONTEXT = 76,
    VT_L2TCMINITSTATENONZEROREGIONS = 78,
    VT_DYNAMICSHAREDDDRSUPPORTED = 80,
    VT_NETWORKHEAPBEHAVIOR = 82
  };
  uint16_t versionMajor() const {
    return GetField<uint16_t>(VT_VERSIONMAJOR, 0);
  }
  uint16_t versionMinor() const {
    return GetField<uint16_t>(VT_VERSIONMINOR, 0);
  }
  const flatbuffers::String *networkName() const {
    return GetPointer<const flatbuffers::String *>(VT_NETWORKNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *requiredFields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_REQUIREDFIELDS);
  }
  const flatbuffers::Vector<uint32_t> *semaphoreInitState() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SEMAPHOREINITSTATE);
  }
  const flatbuffers::Vector<uint8_t> *L2TCMInitState() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_L2TCMINITSTATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>> *dmaRequests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>> *>(VT_DMAREQUESTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>> *nspMulticastTables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>> *>(VT_NSPMULTICASTTABLES);
  }
  const AicMetadataFlat::AICMDHostMulticastEntryTable *hostMulticastTable() const {
    return GetPointer<const AicMetadataFlat::AICMDHostMulticastEntryTable *>(VT_HOSTMULTICASTTABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>> *threadDescriptors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>> *>(VT_THREADDESCRIPTORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>> *constantMappings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>> *>(VT_CONSTANTMAPPINGS);
  }
  uint64_t staticSharedDDRSize() const {
    return GetField<uint64_t>(VT_STATICSHAREDDDRSIZE, 0);
  }
  uint64_t dynamicSharedDDRSize() const {
    return GetField<uint64_t>(VT_DYNAMICSHAREDDDRSIZE, 0);
  }
  uint64_t staticConstantsSize() const {
    return GetField<uint64_t>(VT_STATICCONSTANTSSIZE, 0);
  }
  uint64_t dynamicConstantsSize() const {
    return GetField<uint64_t>(VT_DYNAMICCONSTANTSSIZE, 0);
  }
  uint64_t exitDoorbellOffset() const {
    return GetField<uint64_t>(VT_EXITDOORBELLOFFSET, 0);
  }
  uint32_t l2CachedDDRSize() const {
    return GetField<uint32_t>(VT_L2CACHEDDDRSIZE, 0);
  }
  uint32_t L2TCMInitSize() const {
    return GetField<uint32_t>(VT_L2TCMINITSIZE, 0);
  }
  uint16_t execContextMajorVersion() const {
    return GetField<uint16_t>(VT_EXECCONTEXTMAJORVERSION, 0);
  }
  uint16_t numNSPs() const {
    return GetField<uint16_t>(VT_NUMNSPS, 0);
  }
  uint16_t numSemaphores() const {
    return GetField<uint16_t>(VT_NUMSEMAPHORES, 0);
  }
  uint8_t hwVersionMajor() const {
    return GetField<uint8_t>(VT_HWVERSIONMAJOR, 0);
  }
  uint8_t hwVersionMinor() const {
    return GetField<uint8_t>(VT_HWVERSIONMINOR, 0);
  }
  uint8_t staticSharedDDRECCEnabled() const {
    return GetField<uint8_t>(VT_STATICSHAREDDDRECCENABLED, 0);
  }
  uint8_t dynamicSharedDDRECCEnabled() const {
    return GetField<uint8_t>(VT_DYNAMICSHAREDDDRECCENABLED, 0);
  }
  uint8_t staticConstantsECCEnabled() const {
    return GetField<uint8_t>(VT_STATICCONSTANTSECCENABLED, 0);
  }
  uint8_t dynamicConstantsECCEnabled() const {
    return GetField<uint8_t>(VT_DYNAMICCONSTANTSECCENABLED, 0);
  }
  uint8_t singleVTCMPage() const {
    return GetField<uint8_t>(VT_SINGLEVTCMPAGE, 0);
  }
  uint8_t hasHvxFP() const {
    return GetField<uint8_t>(VT_HASHVXFP, 0);
  }
  uint8_t hasHmxFP() const {
    return GetField<uint8_t>(VT_HASHMXFP, 0);
  }
  uint32_t VTCMSize() const {
    return GetField<uint32_t>(VT_VTCMSIZE, 0);
  }
  uint32_t L2TCMSize() const {
    return GetField<uint32_t>(VT_L2TCMSIZE, 0);
  }
  uint64_t networkHeapSize() const {
    return GetField<uint64_t>(VT_NETWORKHEAPSIZE, 0);
  }
  uint64_t raw_struct_version_length() const {
    return GetField<uint64_t>(VT_RAW_STRUCT_VERSION_LENGTH, 0);
  }
  const AicMetadataFlat::QNNConfigDef *QNNConfig() const {
    return GetPointer<const AicMetadataFlat::QNNConfigDef *>(VT_QNNCONFIG);
  }
  const flatbuffers::Vector<const AicMetadataFlat::AICMDPortEntry *> *portTable() const {
    return GetPointer<const flatbuffers::Vector<const AicMetadataFlat::AICMDPortEntry *> *>(VT_PORTTABLE);
  }
  const flatbuffers::Vector<uint8_t> *execContext() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_EXECCONTEXT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>> *L2TCMInitStateNonZeroRegions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>> *>(VT_L2TCMINITSTATENONZEROREGIONS);
  }
  uint8_t dynamicSharedDDRSupported() const {
    return GetField<uint8_t>(VT_DYNAMICSHAREDDDRSUPPORTED, 0);
  }
  const AicMetadataFlat::networkHeapBehaviorDef *networkHeapBehavior() const {
    return GetPointer<const AicMetadataFlat::networkHeapBehaviorDef *>(VT_NETWORKHEAPBEHAVIOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VERSIONMAJOR, 2) &&
           VerifyField<uint16_t>(verifier, VT_VERSIONMINOR, 2) &&
           VerifyOffset(verifier, VT_NETWORKNAME) &&
           verifier.VerifyString(networkName()) &&
           VerifyOffset(verifier, VT_REQUIREDFIELDS) &&
           verifier.VerifyVector(requiredFields()) &&
           verifier.VerifyVectorOfStrings(requiredFields()) &&
           VerifyOffset(verifier, VT_SEMAPHOREINITSTATE) &&
           verifier.VerifyVector(semaphoreInitState()) &&
           VerifyOffset(verifier, VT_L2TCMINITSTATE) &&
           verifier.VerifyVector(L2TCMInitState()) &&
           VerifyOffset(verifier, VT_DMAREQUESTS) &&
           verifier.VerifyVector(dmaRequests()) &&
           verifier.VerifyVectorOfTables(dmaRequests()) &&
           VerifyOffset(verifier, VT_NSPMULTICASTTABLES) &&
           verifier.VerifyVector(nspMulticastTables()) &&
           verifier.VerifyVectorOfTables(nspMulticastTables()) &&
           VerifyOffset(verifier, VT_HOSTMULTICASTTABLE) &&
           verifier.VerifyTable(hostMulticastTable()) &&
           VerifyOffset(verifier, VT_THREADDESCRIPTORS) &&
           verifier.VerifyVector(threadDescriptors()) &&
           verifier.VerifyVectorOfTables(threadDescriptors()) &&
           VerifyOffset(verifier, VT_CONSTANTMAPPINGS) &&
           verifier.VerifyVector(constantMappings()) &&
           verifier.VerifyVectorOfTables(constantMappings()) &&
           VerifyField<uint64_t>(verifier, VT_STATICSHAREDDDRSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_DYNAMICSHAREDDDRSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_STATICCONSTANTSSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_DYNAMICCONSTANTSSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXITDOORBELLOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_L2CACHEDDDRSIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_L2TCMINITSIZE, 4) &&
           VerifyField<uint16_t>(verifier, VT_EXECCONTEXTMAJORVERSION, 2) &&
           VerifyField<uint16_t>(verifier, VT_NUMNSPS, 2) &&
           VerifyField<uint16_t>(verifier, VT_NUMSEMAPHORES, 2) &&
           VerifyField<uint8_t>(verifier, VT_HWVERSIONMAJOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_HWVERSIONMINOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATICSHAREDDDRECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMICSHAREDDDRECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATICCONSTANTSECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMICCONSTANTSECCENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SINGLEVTCMPAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASHVXFP, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASHMXFP, 1) &&
           VerifyField<uint32_t>(verifier, VT_VTCMSIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_L2TCMSIZE, 4) &&
           VerifyField<uint64_t>(verifier, VT_NETWORKHEAPSIZE, 8) &&
           VerifyField<uint64_t>(verifier, VT_RAW_STRUCT_VERSION_LENGTH, 8) &&
           VerifyOffset(verifier, VT_QNNCONFIG) &&
           verifier.VerifyTable(QNNConfig()) &&
           VerifyOffset(verifier, VT_PORTTABLE) &&
           verifier.VerifyVector(portTable()) &&
           VerifyOffset(verifier, VT_EXECCONTEXT) &&
           verifier.VerifyVector(execContext()) &&
           VerifyOffset(verifier, VT_L2TCMINITSTATENONZEROREGIONS) &&
           verifier.VerifyVector(L2TCMInitStateNonZeroRegions()) &&
           verifier.VerifyVectorOfTables(L2TCMInitStateNonZeroRegions()) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMICSHAREDDDRSUPPORTED, 1) &&
           VerifyOffset(verifier, VT_NETWORKHEAPBEHAVIOR) &&
           verifier.VerifyTable(networkHeapBehavior()) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_versionMajor(uint16_t versionMajor) {
    fbb_.AddElement<uint16_t>(Metadata::VT_VERSIONMAJOR, versionMajor, 0);
  }
  void add_versionMinor(uint16_t versionMinor) {
    fbb_.AddElement<uint16_t>(Metadata::VT_VERSIONMINOR, versionMinor, 0);
  }
  void add_networkName(flatbuffers::Offset<flatbuffers::String> networkName) {
    fbb_.AddOffset(Metadata::VT_NETWORKNAME, networkName);
  }
  void add_requiredFields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> requiredFields) {
    fbb_.AddOffset(Metadata::VT_REQUIREDFIELDS, requiredFields);
  }
  void add_semaphoreInitState(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> semaphoreInitState) {
    fbb_.AddOffset(Metadata::VT_SEMAPHOREINITSTATE, semaphoreInitState);
  }
  void add_L2TCMInitState(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> L2TCMInitState) {
    fbb_.AddOffset(Metadata::VT_L2TCMINITSTATE, L2TCMInitState);
  }
  void add_dmaRequests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>> dmaRequests) {
    fbb_.AddOffset(Metadata::VT_DMAREQUESTS, dmaRequests);
  }
  void add_nspMulticastTables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>>> nspMulticastTables) {
    fbb_.AddOffset(Metadata::VT_NSPMULTICASTTABLES, nspMulticastTables);
  }
  void add_hostMulticastTable(flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntryTable> hostMulticastTable) {
    fbb_.AddOffset(Metadata::VT_HOSTMULTICASTTABLE, hostMulticastTable);
  }
  void add_threadDescriptors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>> threadDescriptors) {
    fbb_.AddOffset(Metadata::VT_THREADDESCRIPTORS, threadDescriptors);
  }
  void add_constantMappings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>> constantMappings) {
    fbb_.AddOffset(Metadata::VT_CONSTANTMAPPINGS, constantMappings);
  }
  void add_staticSharedDDRSize(uint64_t staticSharedDDRSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_STATICSHAREDDDRSIZE, staticSharedDDRSize, 0);
  }
  void add_dynamicSharedDDRSize(uint64_t dynamicSharedDDRSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_DYNAMICSHAREDDDRSIZE, dynamicSharedDDRSize, 0);
  }
  void add_staticConstantsSize(uint64_t staticConstantsSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_STATICCONSTANTSSIZE, staticConstantsSize, 0);
  }
  void add_dynamicConstantsSize(uint64_t dynamicConstantsSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_DYNAMICCONSTANTSSIZE, dynamicConstantsSize, 0);
  }
  void add_exitDoorbellOffset(uint64_t exitDoorbellOffset) {
    fbb_.AddElement<uint64_t>(Metadata::VT_EXITDOORBELLOFFSET, exitDoorbellOffset, 0);
  }
  void add_l2CachedDDRSize(uint32_t l2CachedDDRSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_L2CACHEDDDRSIZE, l2CachedDDRSize, 0);
  }
  void add_L2TCMInitSize(uint32_t L2TCMInitSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_L2TCMINITSIZE, L2TCMInitSize, 0);
  }
  void add_execContextMajorVersion(uint16_t execContextMajorVersion) {
    fbb_.AddElement<uint16_t>(Metadata::VT_EXECCONTEXTMAJORVERSION, execContextMajorVersion, 0);
  }
  void add_numNSPs(uint16_t numNSPs) {
    fbb_.AddElement<uint16_t>(Metadata::VT_NUMNSPS, numNSPs, 0);
  }
  void add_numSemaphores(uint16_t numSemaphores) {
    fbb_.AddElement<uint16_t>(Metadata::VT_NUMSEMAPHORES, numSemaphores, 0);
  }
  void add_hwVersionMajor(uint8_t hwVersionMajor) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HWVERSIONMAJOR, hwVersionMajor, 0);
  }
  void add_hwVersionMinor(uint8_t hwVersionMinor) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HWVERSIONMINOR, hwVersionMinor, 0);
  }
  void add_staticSharedDDRECCEnabled(uint8_t staticSharedDDRECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_STATICSHAREDDDRECCENABLED, staticSharedDDRECCEnabled, 0);
  }
  void add_dynamicSharedDDRECCEnabled(uint8_t dynamicSharedDDRECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_DYNAMICSHAREDDDRECCENABLED, dynamicSharedDDRECCEnabled, 0);
  }
  void add_staticConstantsECCEnabled(uint8_t staticConstantsECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_STATICCONSTANTSECCENABLED, staticConstantsECCEnabled, 0);
  }
  void add_dynamicConstantsECCEnabled(uint8_t dynamicConstantsECCEnabled) {
    fbb_.AddElement<uint8_t>(Metadata::VT_DYNAMICCONSTANTSECCENABLED, dynamicConstantsECCEnabled, 0);
  }
  void add_singleVTCMPage(uint8_t singleVTCMPage) {
    fbb_.AddElement<uint8_t>(Metadata::VT_SINGLEVTCMPAGE, singleVTCMPage, 0);
  }
  void add_hasHvxFP(uint8_t hasHvxFP) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HASHVXFP, hasHvxFP, 0);
  }
  void add_hasHmxFP(uint8_t hasHmxFP) {
    fbb_.AddElement<uint8_t>(Metadata::VT_HASHMXFP, hasHmxFP, 0);
  }
  void add_VTCMSize(uint32_t VTCMSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_VTCMSIZE, VTCMSize, 0);
  }
  void add_L2TCMSize(uint32_t L2TCMSize) {
    fbb_.AddElement<uint32_t>(Metadata::VT_L2TCMSIZE, L2TCMSize, 0);
  }
  void add_networkHeapSize(uint64_t networkHeapSize) {
    fbb_.AddElement<uint64_t>(Metadata::VT_NETWORKHEAPSIZE, networkHeapSize, 0);
  }
  void add_raw_struct_version_length(uint64_t raw_struct_version_length) {
    fbb_.AddElement<uint64_t>(Metadata::VT_RAW_STRUCT_VERSION_LENGTH, raw_struct_version_length, 0);
  }
  void add_QNNConfig(flatbuffers::Offset<AicMetadataFlat::QNNConfigDef> QNNConfig) {
    fbb_.AddOffset(Metadata::VT_QNNCONFIG, QNNConfig);
  }
  void add_portTable(flatbuffers::Offset<flatbuffers::Vector<const AicMetadataFlat::AICMDPortEntry *>> portTable) {
    fbb_.AddOffset(Metadata::VT_PORTTABLE, portTable);
  }
  void add_execContext(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> execContext) {
    fbb_.AddOffset(Metadata::VT_EXECCONTEXT, execContext);
  }
  void add_L2TCMInitStateNonZeroRegions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>>> L2TCMInitStateNonZeroRegions) {
    fbb_.AddOffset(Metadata::VT_L2TCMINITSTATENONZEROREGIONS, L2TCMInitStateNonZeroRegions);
  }
  void add_dynamicSharedDDRSupported(uint8_t dynamicSharedDDRSupported) {
    fbb_.AddElement<uint8_t>(Metadata::VT_DYNAMICSHAREDDDRSUPPORTED, dynamicSharedDDRSupported, 0);
  }
  void add_networkHeapBehavior(flatbuffers::Offset<AicMetadataFlat::networkHeapBehaviorDef> networkHeapBehavior) {
    fbb_.AddOffset(Metadata::VT_NETWORKHEAPBEHAVIOR, networkHeapBehavior);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t versionMajor = 0,
    uint16_t versionMinor = 0,
    flatbuffers::Offset<flatbuffers::String> networkName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> requiredFields = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> semaphoreInitState = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> L2TCMInitState = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>> dmaRequests = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>>> nspMulticastTables = 0,
    flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntryTable> hostMulticastTable = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>> threadDescriptors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>> constantMappings = 0,
    uint64_t staticSharedDDRSize = 0,
    uint64_t dynamicSharedDDRSize = 0,
    uint64_t staticConstantsSize = 0,
    uint64_t dynamicConstantsSize = 0,
    uint64_t exitDoorbellOffset = 0,
    uint32_t l2CachedDDRSize = 0,
    uint32_t L2TCMInitSize = 0,
    uint16_t execContextMajorVersion = 0,
    uint16_t numNSPs = 0,
    uint16_t numSemaphores = 0,
    uint8_t hwVersionMajor = 0,
    uint8_t hwVersionMinor = 0,
    uint8_t staticSharedDDRECCEnabled = 0,
    uint8_t dynamicSharedDDRECCEnabled = 0,
    uint8_t staticConstantsECCEnabled = 0,
    uint8_t dynamicConstantsECCEnabled = 0,
    uint8_t singleVTCMPage = 0,
    uint8_t hasHvxFP = 0,
    uint8_t hasHmxFP = 0,
    uint32_t VTCMSize = 0,
    uint32_t L2TCMSize = 0,
    uint64_t networkHeapSize = 0,
    uint64_t raw_struct_version_length = 0,
    flatbuffers::Offset<AicMetadataFlat::QNNConfigDef> QNNConfig = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AicMetadataFlat::AICMDPortEntry *>> portTable = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> execContext = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>>> L2TCMInitStateNonZeroRegions = 0,
    uint8_t dynamicSharedDDRSupported = 0,
    flatbuffers::Offset<AicMetadataFlat::networkHeapBehaviorDef> networkHeapBehavior = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_raw_struct_version_length(raw_struct_version_length);
  builder_.add_networkHeapSize(networkHeapSize);
  builder_.add_exitDoorbellOffset(exitDoorbellOffset);
  builder_.add_dynamicConstantsSize(dynamicConstantsSize);
  builder_.add_staticConstantsSize(staticConstantsSize);
  builder_.add_dynamicSharedDDRSize(dynamicSharedDDRSize);
  builder_.add_staticSharedDDRSize(staticSharedDDRSize);
  builder_.add_networkHeapBehavior(networkHeapBehavior);
  builder_.add_L2TCMInitStateNonZeroRegions(L2TCMInitStateNonZeroRegions);
  builder_.add_execContext(execContext);
  builder_.add_portTable(portTable);
  builder_.add_QNNConfig(QNNConfig);
  builder_.add_L2TCMSize(L2TCMSize);
  builder_.add_VTCMSize(VTCMSize);
  builder_.add_L2TCMInitSize(L2TCMInitSize);
  builder_.add_l2CachedDDRSize(l2CachedDDRSize);
  builder_.add_constantMappings(constantMappings);
  builder_.add_threadDescriptors(threadDescriptors);
  builder_.add_hostMulticastTable(hostMulticastTable);
  builder_.add_nspMulticastTables(nspMulticastTables);
  builder_.add_dmaRequests(dmaRequests);
  builder_.add_L2TCMInitState(L2TCMInitState);
  builder_.add_semaphoreInitState(semaphoreInitState);
  builder_.add_requiredFields(requiredFields);
  builder_.add_networkName(networkName);
  builder_.add_numSemaphores(numSemaphores);
  builder_.add_numNSPs(numNSPs);
  builder_.add_execContextMajorVersion(execContextMajorVersion);
  builder_.add_versionMinor(versionMinor);
  builder_.add_versionMajor(versionMajor);
  builder_.add_dynamicSharedDDRSupported(dynamicSharedDDRSupported);
  builder_.add_hasHmxFP(hasHmxFP);
  builder_.add_hasHvxFP(hasHvxFP);
  builder_.add_singleVTCMPage(singleVTCMPage);
  builder_.add_dynamicConstantsECCEnabled(dynamicConstantsECCEnabled);
  builder_.add_staticConstantsECCEnabled(staticConstantsECCEnabled);
  builder_.add_dynamicSharedDDRECCEnabled(dynamicSharedDDRECCEnabled);
  builder_.add_staticSharedDDRECCEnabled(staticSharedDDRECCEnabled);
  builder_.add_hwVersionMinor(hwVersionMinor);
  builder_.add_hwVersionMajor(hwVersionMajor);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t versionMajor = 0,
    uint16_t versionMinor = 0,
    const char *networkName = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *requiredFields = nullptr,
    const std::vector<uint32_t> *semaphoreInitState = nullptr,
    const std::vector<uint8_t> *L2TCMInitState = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>> *dmaRequests = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>> *nspMulticastTables = nullptr,
    flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntryTable> hostMulticastTable = 0,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>> *threadDescriptors = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>> *constantMappings = nullptr,
    uint64_t staticSharedDDRSize = 0,
    uint64_t dynamicSharedDDRSize = 0,
    uint64_t staticConstantsSize = 0,
    uint64_t dynamicConstantsSize = 0,
    uint64_t exitDoorbellOffset = 0,
    uint32_t l2CachedDDRSize = 0,
    uint32_t L2TCMInitSize = 0,
    uint16_t execContextMajorVersion = 0,
    uint16_t numNSPs = 0,
    uint16_t numSemaphores = 0,
    uint8_t hwVersionMajor = 0,
    uint8_t hwVersionMinor = 0,
    uint8_t staticSharedDDRECCEnabled = 0,
    uint8_t dynamicSharedDDRECCEnabled = 0,
    uint8_t staticConstantsECCEnabled = 0,
    uint8_t dynamicConstantsECCEnabled = 0,
    uint8_t singleVTCMPage = 0,
    uint8_t hasHvxFP = 0,
    uint8_t hasHmxFP = 0,
    uint32_t VTCMSize = 0,
    uint32_t L2TCMSize = 0,
    uint64_t networkHeapSize = 0,
    uint64_t raw_struct_version_length = 0,
    flatbuffers::Offset<AicMetadataFlat::QNNConfigDef> QNNConfig = 0,
    const std::vector<AicMetadataFlat::AICMDPortEntry> *portTable = nullptr,
    const std::vector<uint8_t> *execContext = nullptr,
    const std::vector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>> *L2TCMInitStateNonZeroRegions = nullptr,
    uint8_t dynamicSharedDDRSupported = 0,
    flatbuffers::Offset<AicMetadataFlat::networkHeapBehaviorDef> networkHeapBehavior = 0) {
  auto networkName__ = networkName ? _fbb.CreateString(networkName) : 0;
  auto requiredFields__ = requiredFields ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*requiredFields) : 0;
  auto semaphoreInitState__ = semaphoreInitState ? _fbb.CreateVector<uint32_t>(*semaphoreInitState) : 0;
  auto L2TCMInitState__ = L2TCMInitState ? _fbb.CreateVector<uint8_t>(*L2TCMInitState) : 0;
  auto dmaRequests__ = dmaRequests ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>>(*dmaRequests) : 0;
  auto nspMulticastTables__ = nspMulticastTables ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>>(*nspMulticastTables) : 0;
  auto threadDescriptors__ = threadDescriptors ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>>(*threadDescriptors) : 0;
  auto constantMappings__ = constantMappings ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>>(*constantMappings) : 0;
  auto portTable__ = portTable ? _fbb.CreateVectorOfStructs<AicMetadataFlat::AICMDPortEntry>(*portTable) : 0;
  auto execContext__ = execContext ? _fbb.CreateVector<uint8_t>(*execContext) : 0;
  auto L2TCMInitStateNonZeroRegions__ = L2TCMInitStateNonZeroRegions ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>>(*L2TCMInitStateNonZeroRegions) : 0;
  return AicMetadataFlat::CreateMetadata(
      _fbb,
      versionMajor,
      versionMinor,
      networkName__,
      requiredFields__,
      semaphoreInitState__,
      L2TCMInitState__,
      dmaRequests__,
      nspMulticastTables__,
      hostMulticastTable,
      threadDescriptors__,
      constantMappings__,
      staticSharedDDRSize,
      dynamicSharedDDRSize,
      staticConstantsSize,
      dynamicConstantsSize,
      exitDoorbellOffset,
      l2CachedDDRSize,
      L2TCMInitSize,
      execContextMajorVersion,
      numNSPs,
      numSemaphores,
      hwVersionMajor,
      hwVersionMinor,
      staticSharedDDRECCEnabled,
      dynamicSharedDDRECCEnabled,
      staticConstantsECCEnabled,
      dynamicConstantsECCEnabled,
      singleVTCMPage,
      hasHvxFP,
      hasHmxFP,
      VTCMSize,
      L2TCMSize,
      networkHeapSize,
      raw_struct_version_length,
      QNNConfig,
      portTable__,
      execContext__,
      L2TCMInitStateNonZeroRegions__,
      dynamicSharedDDRSupported,
      networkHeapBehavior);
}

flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AICMDSemaphoreOpT *AICMDSemaphoreOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDSemaphoreOpT>(new AICMDSemaphoreOpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDSemaphoreOp::UnPackTo(AICMDSemaphoreOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = semNum(); _o->semNum = _e; }
  { auto _e = semValue(); _o->semValue = _e; }
  { auto _e = semOp(); _o->semOp = _e; }
  { auto _e = preOrPost(); _o->preOrPost = _e; }
  { auto _e = inSyncFence(); _o->inSyncFence = _e; }
  { auto _e = outSyncFence(); _o->outSyncFence = _e; }
}

inline flatbuffers::Offset<AICMDSemaphoreOp> AICMDSemaphoreOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDSemaphoreOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDSemaphoreOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDSemaphoreOp> CreateAICMDSemaphoreOp(flatbuffers::FlatBufferBuilder &_fbb, const AICMDSemaphoreOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDSemaphoreOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _semNum = _o->semNum;
  auto _semValue = _o->semValue;
  auto _semOp = _o->semOp;
  auto _preOrPost = _o->preOrPost;
  auto _inSyncFence = _o->inSyncFence;
  auto _outSyncFence = _o->outSyncFence;
  return AicMetadataFlat::CreateAICMDSemaphoreOp(
      _fbb,
      _semNum,
      _semValue,
      _semOp,
      _preOrPost,
      _inSyncFence,
      _outSyncFence);
}

inline AICMDDoorbellOpT *AICMDDoorbellOp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDDoorbellOpT>(new AICMDDoorbellOpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDDoorbellOp::UnPackTo(AICMDDoorbellOpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = data(); _o->data = _e; }
  { auto _e = mcId(); _o->mcId = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<AICMDDoorbellOp> AICMDDoorbellOp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDoorbellOpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDDoorbellOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDDoorbellOp> CreateAICMDDoorbellOp(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDoorbellOpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDDoorbellOpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset = _o->offset;
  auto _data = _o->data;
  auto _mcId = _o->mcId;
  auto _size = _o->size;
  return AicMetadataFlat::CreateAICMDDoorbellOp(
      _fbb,
      _offset,
      _data,
      _mcId,
      _size);
}

inline AICMDDMARequestT::AICMDDMARequestT(const AICMDDMARequestT &o)
      : hostOffset(o.hostOffset),
        devOffset(o.devOffset),
        size(o.size),
        num(o.num),
        mcId(o.mcId),
        devAddrSpace(o.devAddrSpace),
        inOut(o.inOut),
        portId(o.portId),
        transactionId(o.transactionId) {
  semaphoreOps.reserve(o.semaphoreOps.size());
  for (const auto &semaphoreOps_ : o.semaphoreOps) { semaphoreOps.emplace_back((semaphoreOps_) ? new AicMetadataFlat::AICMDSemaphoreOpT(*semaphoreOps_) : nullptr); }
  doorbellOps.reserve(o.doorbellOps.size());
  for (const auto &doorbellOps_ : o.doorbellOps) { doorbellOps.emplace_back((doorbellOps_) ? new AicMetadataFlat::AICMDDoorbellOpT(*doorbellOps_) : nullptr); }
}

inline AICMDDMARequestT &AICMDDMARequestT::operator=(AICMDDMARequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(semaphoreOps, o.semaphoreOps);
  std::swap(doorbellOps, o.doorbellOps);
  std::swap(hostOffset, o.hostOffset);
  std::swap(devOffset, o.devOffset);
  std::swap(size, o.size);
  std::swap(num, o.num);
  std::swap(mcId, o.mcId);
  std::swap(devAddrSpace, o.devAddrSpace);
  std::swap(inOut, o.inOut);
  std::swap(portId, o.portId);
  std::swap(transactionId, o.transactionId);
  return *this;
}

inline AICMDDMARequestT *AICMDDMARequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDDMARequestT>(new AICMDDMARequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDDMARequest::UnPackTo(AICMDDMARequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = semaphoreOps(); if (_e) { _o->semaphoreOps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->semaphoreOps[_i]) { _e->Get(_i)->UnPackTo(_o->semaphoreOps[_i].get(), _resolver); } else { _o->semaphoreOps[_i] = std::unique_ptr<AicMetadataFlat::AICMDSemaphoreOpT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->semaphoreOps.resize(0); } }
  { auto _e = doorbellOps(); if (_e) { _o->doorbellOps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->doorbellOps[_i]) { _e->Get(_i)->UnPackTo(_o->doorbellOps[_i].get(), _resolver); } else { _o->doorbellOps[_i] = std::unique_ptr<AicMetadataFlat::AICMDDoorbellOpT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->doorbellOps.resize(0); } }
  { auto _e = hostOffset(); _o->hostOffset = _e; }
  { auto _e = devOffset(); _o->devOffset = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = num(); _o->num = _e; }
  { auto _e = mcId(); _o->mcId = _e; }
  { auto _e = devAddrSpace(); _o->devAddrSpace = _e; }
  { auto _e = inOut(); _o->inOut = _e; }
  { auto _e = portId(); _o->portId = _e; }
  { auto _e = transactionId(); _o->transactionId = _e; }
}

inline flatbuffers::Offset<AICMDDMARequest> AICMDDMARequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDMARequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDDMARequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDDMARequest> CreateAICMDDMARequest(flatbuffers::FlatBufferBuilder &_fbb, const AICMDDMARequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDDMARequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _semaphoreOps = _o->semaphoreOps.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDSemaphoreOp>> (_o->semaphoreOps.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDSemaphoreOp(*__va->__fbb, __va->__o->semaphoreOps[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _doorbellOps = _o->doorbellOps.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDDoorbellOp>> (_o->doorbellOps.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDDoorbellOp(*__va->__fbb, __va->__o->doorbellOps[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _hostOffset = _o->hostOffset;
  auto _devOffset = _o->devOffset;
  auto _size = _o->size;
  auto _num = _o->num;
  auto _mcId = _o->mcId;
  auto _devAddrSpace = _o->devAddrSpace;
  auto _inOut = _o->inOut;
  auto _portId = _o->portId;
  auto _transactionId = _o->transactionId;
  return AicMetadataFlat::CreateAICMDDMARequest(
      _fbb,
      _semaphoreOps,
      _doorbellOps,
      _hostOffset,
      _devOffset,
      _size,
      _num,
      _mcId,
      _devAddrSpace,
      _inOut,
      _portId,
      _transactionId);
}

inline AICMDNSPMulticastEntryT *AICMDNSPMulticastEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDNSPMulticastEntryT>(new AICMDNSPMulticastEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDNSPMulticastEntry::UnPackTo(AICMDNSPMulticastEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = baseAddrOffset(); _o->baseAddrOffset = _e; }
  { auto _e = mask(); _o->mask = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = addrSpace(); _o->addrSpace = _e; }
  { auto _e = dynamic(); _o->dynamic = _e; }
}

inline flatbuffers::Offset<AICMDNSPMulticastEntry> AICMDNSPMulticastEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDNSPMulticastEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDNSPMulticastEntry> CreateAICMDNSPMulticastEntry(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDNSPMulticastEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _baseAddrOffset = _o->baseAddrOffset;
  auto _mask = _o->mask;
  auto _size = _o->size;
  auto _addrSpace = _o->addrSpace;
  auto _dynamic = _o->dynamic;
  return AicMetadataFlat::CreateAICMDNSPMulticastEntry(
      _fbb,
      _baseAddrOffset,
      _mask,
      _size,
      _addrSpace,
      _dynamic);
}

inline AICMDNSPMulticastEntryTableT::AICMDNSPMulticastEntryTableT(const AICMDNSPMulticastEntryTableT &o) {
  multicastEntries.reserve(o.multicastEntries.size());
  for (const auto &multicastEntries_ : o.multicastEntries) { multicastEntries.emplace_back((multicastEntries_) ? new AicMetadataFlat::AICMDNSPMulticastEntryT(*multicastEntries_) : nullptr); }
}

inline AICMDNSPMulticastEntryTableT &AICMDNSPMulticastEntryTableT::operator=(AICMDNSPMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT {
  std::swap(multicastEntries, o.multicastEntries);
  return *this;
}

inline AICMDNSPMulticastEntryTableT *AICMDNSPMulticastEntryTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDNSPMulticastEntryTableT>(new AICMDNSPMulticastEntryTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDNSPMulticastEntryTable::UnPackTo(AICMDNSPMulticastEntryTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = multicastEntries(); if (_e) { _o->multicastEntries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->multicastEntries[_i]) { _e->Get(_i)->UnPackTo(_o->multicastEntries[_i].get(), _resolver); } else { _o->multicastEntries[_i] = std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->multicastEntries.resize(0); } }
}

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable> AICMDNSPMulticastEntryTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDNSPMulticastEntryTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDNSPMulticastEntryTable> CreateAICMDNSPMulticastEntryTable(flatbuffers::FlatBufferBuilder &_fbb, const AICMDNSPMulticastEntryTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDNSPMulticastEntryTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _multicastEntries = _o->multicastEntries.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntry>> (_o->multicastEntries.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDNSPMulticastEntry(*__va->__fbb, __va->__o->multicastEntries[i].get(), __va->__rehasher); }, &_va ) : 0;
  return AicMetadataFlat::CreateAICMDNSPMulticastEntryTable(
      _fbb,
      _multicastEntries);
}

inline AICMDHostMulticastEntryT *AICMDHostMulticastEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDHostMulticastEntryT>(new AICMDHostMulticastEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDHostMulticastEntry::UnPackTo(AICMDHostMulticastEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mask(); _o->mask = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<AICMDHostMulticastEntry> AICMDHostMulticastEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDHostMulticastEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDHostMulticastEntry> CreateAICMDHostMulticastEntry(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDHostMulticastEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mask = _o->mask;
  auto _size = _o->size;
  return AicMetadataFlat::CreateAICMDHostMulticastEntry(
      _fbb,
      _mask,
      _size);
}

inline AICMDHostMulticastEntryTableT::AICMDHostMulticastEntryTableT(const AICMDHostMulticastEntryTableT &o) {
  multicastEntries.reserve(o.multicastEntries.size());
  for (const auto &multicastEntries_ : o.multicastEntries) { multicastEntries.emplace_back((multicastEntries_) ? new AicMetadataFlat::AICMDHostMulticastEntryT(*multicastEntries_) : nullptr); }
}

inline AICMDHostMulticastEntryTableT &AICMDHostMulticastEntryTableT::operator=(AICMDHostMulticastEntryTableT o) FLATBUFFERS_NOEXCEPT {
  std::swap(multicastEntries, o.multicastEntries);
  return *this;
}

inline AICMDHostMulticastEntryTableT *AICMDHostMulticastEntryTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDHostMulticastEntryTableT>(new AICMDHostMulticastEntryTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDHostMulticastEntryTable::UnPackTo(AICMDHostMulticastEntryTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = multicastEntries(); if (_e) { _o->multicastEntries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->multicastEntries[_i]) { _e->Get(_i)->UnPackTo(_o->multicastEntries[_i].get(), _resolver); } else { _o->multicastEntries[_i] = std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->multicastEntries.resize(0); } }
}

inline flatbuffers::Offset<AICMDHostMulticastEntryTable> AICMDHostMulticastEntryTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDHostMulticastEntryTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDHostMulticastEntryTable> CreateAICMDHostMulticastEntryTable(flatbuffers::FlatBufferBuilder &_fbb, const AICMDHostMulticastEntryTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDHostMulticastEntryTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _multicastEntries = _o->multicastEntries.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDHostMulticastEntry>> (_o->multicastEntries.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDHostMulticastEntry(*__va->__fbb, __va->__o->multicastEntries[i].get(), __va->__rehasher); }, &_va ) : 0;
  return AicMetadataFlat::CreateAICMDHostMulticastEntryTable(
      _fbb,
      _multicastEntries);
}

inline AICMDThreadDescriptorT *AICMDThreadDescriptor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDThreadDescriptorT>(new AICMDThreadDescriptorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDThreadDescriptor::UnPackTo(AICMDThreadDescriptorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entryPoint(); _o->entryPoint = _e; }
  { auto _e = typeMask(); _o->typeMask = _e; }
}

inline flatbuffers::Offset<AICMDThreadDescriptor> AICMDThreadDescriptor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDThreadDescriptorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDThreadDescriptor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDThreadDescriptor> CreateAICMDThreadDescriptor(flatbuffers::FlatBufferBuilder &_fbb, const AICMDThreadDescriptorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDThreadDescriptorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _entryPoint = _o->entryPoint;
  auto _typeMask = _o->typeMask;
  return AicMetadataFlat::CreateAICMDThreadDescriptor(
      _fbb,
      _entryPoint,
      _typeMask);
}

inline AICMDConstantMappingT *AICMDConstantMapping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AICMDConstantMappingT>(new AICMDConstantMappingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AICMDConstantMapping::UnPackTo(AICMDConstantMappingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = constantDataBaseOffset(); _o->constantDataBaseOffset = _e; }
  { auto _e = coreMask(); _o->coreMask = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<AICMDConstantMapping> AICMDConstantMapping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AICMDConstantMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAICMDConstantMapping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AICMDConstantMapping> CreateAICMDConstantMapping(flatbuffers::FlatBufferBuilder &_fbb, const AICMDConstantMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AICMDConstantMappingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _constantDataBaseOffset = _o->constantDataBaseOffset;
  auto _coreMask = _o->coreMask;
  auto _size = _o->size;
  return AicMetadataFlat::CreateAICMDConstantMapping(
      _fbb,
      _constantDataBaseOffset,
      _coreMask,
      _size);
}

inline QNNConfigDefT *QNNConfigDef::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QNNConfigDefT>(new QNNConfigDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QNNConfigDef::UnPackTo(QNNConfigDefT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Constants(); _o->Constants = _e; }
}

inline flatbuffers::Offset<QNNConfigDef> QNNConfigDef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QNNConfigDefT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQNNConfigDef(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QNNConfigDef> CreateQNNConfigDef(flatbuffers::FlatBufferBuilder &_fbb, const QNNConfigDefT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QNNConfigDefT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Constants = _o->Constants;
  return AicMetadataFlat::CreateQNNConfigDef(
      _fbb,
      _Constants);
}

inline networkHeapBehaviorDefT *networkHeapBehaviorDef::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<networkHeapBehaviorDefT>(new networkHeapBehaviorDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void networkHeapBehaviorDef::UnPackTo(networkHeapBehaviorDefT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = onNetworkDeactivate(); _o->onNetworkDeactivate = _e; }
}

inline flatbuffers::Offset<networkHeapBehaviorDef> networkHeapBehaviorDef::Pack(flatbuffers::FlatBufferBuilder &_fbb, const networkHeapBehaviorDefT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatenetworkHeapBehaviorDef(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<networkHeapBehaviorDef> CreatenetworkHeapBehaviorDef(flatbuffers::FlatBufferBuilder &_fbb, const networkHeapBehaviorDefT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const networkHeapBehaviorDefT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _onNetworkDeactivate = _o->onNetworkDeactivate;
  return AicMetadataFlat::CreatenetworkHeapBehaviorDef(
      _fbb,
      _onNetworkDeactivate);
}

inline NonZeroRegionT *NonZeroRegion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonZeroRegionT>(new NonZeroRegionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonZeroRegion::UnPackTo(NonZeroRegionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start(); _o->start = _e; }
  { auto _e = end(); _o->end = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<NonZeroRegion> NonZeroRegion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroRegionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonZeroRegion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonZeroRegion> CreateNonZeroRegion(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroRegionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonZeroRegionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start = _o->start;
  auto _end = _o->end;
  auto _size = _o->size;
  return AicMetadataFlat::CreateNonZeroRegion(
      _fbb,
      _start,
      _end,
      _size);
}

inline MetadataT::MetadataT(const MetadataT &o)
      : versionMajor(o.versionMajor),
        versionMinor(o.versionMinor),
        networkName(o.networkName),
        requiredFields(o.requiredFields),
        semaphoreInitState(o.semaphoreInitState),
        L2TCMInitState(o.L2TCMInitState),
        hostMulticastTable((o.hostMulticastTable) ? new AicMetadataFlat::AICMDHostMulticastEntryTableT(*o.hostMulticastTable) : nullptr),
        staticSharedDDRSize(o.staticSharedDDRSize),
        dynamicSharedDDRSize(o.dynamicSharedDDRSize),
        staticConstantsSize(o.staticConstantsSize),
        dynamicConstantsSize(o.dynamicConstantsSize),
        exitDoorbellOffset(o.exitDoorbellOffset),
        l2CachedDDRSize(o.l2CachedDDRSize),
        L2TCMInitSize(o.L2TCMInitSize),
        execContextMajorVersion(o.execContextMajorVersion),
        numNSPs(o.numNSPs),
        numSemaphores(o.numSemaphores),
        hwVersionMajor(o.hwVersionMajor),
        hwVersionMinor(o.hwVersionMinor),
        staticSharedDDRECCEnabled(o.staticSharedDDRECCEnabled),
        dynamicSharedDDRECCEnabled(o.dynamicSharedDDRECCEnabled),
        staticConstantsECCEnabled(o.staticConstantsECCEnabled),
        dynamicConstantsECCEnabled(o.dynamicConstantsECCEnabled),
        singleVTCMPage(o.singleVTCMPage),
        hasHvxFP(o.hasHvxFP),
        hasHmxFP(o.hasHmxFP),
        VTCMSize(o.VTCMSize),
        L2TCMSize(o.L2TCMSize),
        networkHeapSize(o.networkHeapSize),
        raw_struct_version_length(o.raw_struct_version_length),
        QNNConfig((o.QNNConfig) ? new AicMetadataFlat::QNNConfigDefT(*o.QNNConfig) : nullptr),
        portTable(o.portTable),
        execContext(o.execContext),
        dynamicSharedDDRSupported(o.dynamicSharedDDRSupported),
        networkHeapBehavior((o.networkHeapBehavior) ? new AicMetadataFlat::networkHeapBehaviorDefT(*o.networkHeapBehavior) : nullptr) {
  dmaRequests.reserve(o.dmaRequests.size());
  for (const auto &dmaRequests_ : o.dmaRequests) { dmaRequests.emplace_back((dmaRequests_) ? new AicMetadataFlat::AICMDDMARequestT(*dmaRequests_) : nullptr); }
  nspMulticastTables.reserve(o.nspMulticastTables.size());
  for (const auto &nspMulticastTables_ : o.nspMulticastTables) { nspMulticastTables.emplace_back((nspMulticastTables_) ? new AicMetadataFlat::AICMDNSPMulticastEntryTableT(*nspMulticastTables_) : nullptr); }
  threadDescriptors.reserve(o.threadDescriptors.size());
  for (const auto &threadDescriptors_ : o.threadDescriptors) { threadDescriptors.emplace_back((threadDescriptors_) ? new AicMetadataFlat::AICMDThreadDescriptorT(*threadDescriptors_) : nullptr); }
  constantMappings.reserve(o.constantMappings.size());
  for (const auto &constantMappings_ : o.constantMappings) { constantMappings.emplace_back((constantMappings_) ? new AicMetadataFlat::AICMDConstantMappingT(*constantMappings_) : nullptr); }
  L2TCMInitStateNonZeroRegions.reserve(o.L2TCMInitStateNonZeroRegions.size());
  for (const auto &L2TCMInitStateNonZeroRegions_ : o.L2TCMInitStateNonZeroRegions) { L2TCMInitStateNonZeroRegions.emplace_back((L2TCMInitStateNonZeroRegions_) ? new AicMetadataFlat::NonZeroRegionT(*L2TCMInitStateNonZeroRegions_) : nullptr); }
}

inline MetadataT &MetadataT::operator=(MetadataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(versionMajor, o.versionMajor);
  std::swap(versionMinor, o.versionMinor);
  std::swap(networkName, o.networkName);
  std::swap(requiredFields, o.requiredFields);
  std::swap(semaphoreInitState, o.semaphoreInitState);
  std::swap(L2TCMInitState, o.L2TCMInitState);
  std::swap(dmaRequests, o.dmaRequests);
  std::swap(nspMulticastTables, o.nspMulticastTables);
  std::swap(hostMulticastTable, o.hostMulticastTable);
  std::swap(threadDescriptors, o.threadDescriptors);
  std::swap(constantMappings, o.constantMappings);
  std::swap(staticSharedDDRSize, o.staticSharedDDRSize);
  std::swap(dynamicSharedDDRSize, o.dynamicSharedDDRSize);
  std::swap(staticConstantsSize, o.staticConstantsSize);
  std::swap(dynamicConstantsSize, o.dynamicConstantsSize);
  std::swap(exitDoorbellOffset, o.exitDoorbellOffset);
  std::swap(l2CachedDDRSize, o.l2CachedDDRSize);
  std::swap(L2TCMInitSize, o.L2TCMInitSize);
  std::swap(execContextMajorVersion, o.execContextMajorVersion);
  std::swap(numNSPs, o.numNSPs);
  std::swap(numSemaphores, o.numSemaphores);
  std::swap(hwVersionMajor, o.hwVersionMajor);
  std::swap(hwVersionMinor, o.hwVersionMinor);
  std::swap(staticSharedDDRECCEnabled, o.staticSharedDDRECCEnabled);
  std::swap(dynamicSharedDDRECCEnabled, o.dynamicSharedDDRECCEnabled);
  std::swap(staticConstantsECCEnabled, o.staticConstantsECCEnabled);
  std::swap(dynamicConstantsECCEnabled, o.dynamicConstantsECCEnabled);
  std::swap(singleVTCMPage, o.singleVTCMPage);
  std::swap(hasHvxFP, o.hasHvxFP);
  std::swap(hasHmxFP, o.hasHmxFP);
  std::swap(VTCMSize, o.VTCMSize);
  std::swap(L2TCMSize, o.L2TCMSize);
  std::swap(networkHeapSize, o.networkHeapSize);
  std::swap(raw_struct_version_length, o.raw_struct_version_length);
  std::swap(QNNConfig, o.QNNConfig);
  std::swap(portTable, o.portTable);
  std::swap(execContext, o.execContext);
  std::swap(L2TCMInitStateNonZeroRegions, o.L2TCMInitStateNonZeroRegions);
  std::swap(dynamicSharedDDRSupported, o.dynamicSharedDDRSupported);
  std::swap(networkHeapBehavior, o.networkHeapBehavior);
  return *this;
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MetadataT>(new MetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = versionMajor(); _o->versionMajor = _e; }
  { auto _e = versionMinor(); _o->versionMinor = _e; }
  { auto _e = networkName(); if (_e) _o->networkName = _e->str(); }
  { auto _e = requiredFields(); if (_e) { _o->requiredFields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requiredFields[_i] = _e->Get(_i)->str(); } } else { _o->requiredFields.resize(0); } }
  { auto _e = semaphoreInitState(); if (_e) { _o->semaphoreInitState.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->semaphoreInitState[_i] = _e->Get(_i); } } else { _o->semaphoreInitState.resize(0); } }
  { auto _e = L2TCMInitState(); if (_e) { _o->L2TCMInitState.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->L2TCMInitState.begin()); } }
  { auto _e = dmaRequests(); if (_e) { _o->dmaRequests.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->dmaRequests[_i]) { _e->Get(_i)->UnPackTo(_o->dmaRequests[_i].get(), _resolver); } else { _o->dmaRequests[_i] = std::unique_ptr<AicMetadataFlat::AICMDDMARequestT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->dmaRequests.resize(0); } }
  { auto _e = nspMulticastTables(); if (_e) { _o->nspMulticastTables.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nspMulticastTables[_i]) { _e->Get(_i)->UnPackTo(_o->nspMulticastTables[_i].get(), _resolver); } else { _o->nspMulticastTables[_i] = std::unique_ptr<AicMetadataFlat::AICMDNSPMulticastEntryTableT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->nspMulticastTables.resize(0); } }
  { auto _e = hostMulticastTable(); if (_e) { if(_o->hostMulticastTable) { _e->UnPackTo(_o->hostMulticastTable.get(), _resolver); } else { _o->hostMulticastTable = std::unique_ptr<AicMetadataFlat::AICMDHostMulticastEntryTableT>(_e->UnPack(_resolver)); } } else if (_o->hostMulticastTable) { _o->hostMulticastTable.reset(); } }
  { auto _e = threadDescriptors(); if (_e) { _o->threadDescriptors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->threadDescriptors[_i]) { _e->Get(_i)->UnPackTo(_o->threadDescriptors[_i].get(), _resolver); } else { _o->threadDescriptors[_i] = std::unique_ptr<AicMetadataFlat::AICMDThreadDescriptorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->threadDescriptors.resize(0); } }
  { auto _e = constantMappings(); if (_e) { _o->constantMappings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->constantMappings[_i]) { _e->Get(_i)->UnPackTo(_o->constantMappings[_i].get(), _resolver); } else { _o->constantMappings[_i] = std::unique_ptr<AicMetadataFlat::AICMDConstantMappingT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->constantMappings.resize(0); } }
  { auto _e = staticSharedDDRSize(); _o->staticSharedDDRSize = _e; }
  { auto _e = dynamicSharedDDRSize(); _o->dynamicSharedDDRSize = _e; }
  { auto _e = staticConstantsSize(); _o->staticConstantsSize = _e; }
  { auto _e = dynamicConstantsSize(); _o->dynamicConstantsSize = _e; }
  { auto _e = exitDoorbellOffset(); _o->exitDoorbellOffset = _e; }
  { auto _e = l2CachedDDRSize(); _o->l2CachedDDRSize = _e; }
  { auto _e = L2TCMInitSize(); _o->L2TCMInitSize = _e; }
  { auto _e = execContextMajorVersion(); _o->execContextMajorVersion = _e; }
  { auto _e = numNSPs(); _o->numNSPs = _e; }
  { auto _e = numSemaphores(); _o->numSemaphores = _e; }
  { auto _e = hwVersionMajor(); _o->hwVersionMajor = _e; }
  { auto _e = hwVersionMinor(); _o->hwVersionMinor = _e; }
  { auto _e = staticSharedDDRECCEnabled(); _o->staticSharedDDRECCEnabled = _e; }
  { auto _e = dynamicSharedDDRECCEnabled(); _o->dynamicSharedDDRECCEnabled = _e; }
  { auto _e = staticConstantsECCEnabled(); _o->staticConstantsECCEnabled = _e; }
  { auto _e = dynamicConstantsECCEnabled(); _o->dynamicConstantsECCEnabled = _e; }
  { auto _e = singleVTCMPage(); _o->singleVTCMPage = _e; }
  { auto _e = hasHvxFP(); _o->hasHvxFP = _e; }
  { auto _e = hasHmxFP(); _o->hasHmxFP = _e; }
  { auto _e = VTCMSize(); _o->VTCMSize = _e; }
  { auto _e = L2TCMSize(); _o->L2TCMSize = _e; }
  { auto _e = networkHeapSize(); _o->networkHeapSize = _e; }
  { auto _e = raw_struct_version_length(); _o->raw_struct_version_length = _e; }
  { auto _e = QNNConfig(); if (_e) { if(_o->QNNConfig) { _e->UnPackTo(_o->QNNConfig.get(), _resolver); } else { _o->QNNConfig = std::unique_ptr<AicMetadataFlat::QNNConfigDefT>(_e->UnPack(_resolver)); } } else if (_o->QNNConfig) { _o->QNNConfig.reset(); } }
  { auto _e = portTable(); if (_e) { _o->portTable.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->portTable[_i] = *_e->Get(_i); } } else { _o->portTable.resize(0); } }
  { auto _e = execContext(); if (_e) { _o->execContext.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->execContext.begin()); } }
  { auto _e = L2TCMInitStateNonZeroRegions(); if (_e) { _o->L2TCMInitStateNonZeroRegions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->L2TCMInitStateNonZeroRegions[_i]) { _e->Get(_i)->UnPackTo(_o->L2TCMInitStateNonZeroRegions[_i].get(), _resolver); } else { _o->L2TCMInitStateNonZeroRegions[_i] = std::unique_ptr<AicMetadataFlat::NonZeroRegionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->L2TCMInitStateNonZeroRegions.resize(0); } }
  { auto _e = dynamicSharedDDRSupported(); _o->dynamicSharedDDRSupported = _e; }
  { auto _e = networkHeapBehavior(); if (_e) { if(_o->networkHeapBehavior) { _e->UnPackTo(_o->networkHeapBehavior.get(), _resolver); } else { _o->networkHeapBehavior = std::unique_ptr<AicMetadataFlat::networkHeapBehaviorDefT>(_e->UnPack(_resolver)); } } else if (_o->networkHeapBehavior) { _o->networkHeapBehavior.reset(); } }
}

inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _versionMajor = _o->versionMajor;
  auto _versionMinor = _o->versionMinor;
  auto _networkName = _o->networkName.empty() ? 0 : _fbb.CreateString(_o->networkName);
  auto _requiredFields = _o->requiredFields.size() ? _fbb.CreateVectorOfStrings(_o->requiredFields) : 0;
  auto _semaphoreInitState = _o->semaphoreInitState.size() ? _fbb.CreateVector(_o->semaphoreInitState) : 0;
  auto _L2TCMInitState = _o->L2TCMInitState.size() ? _fbb.CreateVector(_o->L2TCMInitState) : 0;
  auto _dmaRequests = _o->dmaRequests.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDDMARequest>> (_o->dmaRequests.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDDMARequest(*__va->__fbb, __va->__o->dmaRequests[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nspMulticastTables = _o->nspMulticastTables.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDNSPMulticastEntryTable>> (_o->nspMulticastTables.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDNSPMulticastEntryTable(*__va->__fbb, __va->__o->nspMulticastTables[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _hostMulticastTable = _o->hostMulticastTable ? CreateAICMDHostMulticastEntryTable(_fbb, _o->hostMulticastTable.get(), _rehasher) : 0;
  auto _threadDescriptors = _o->threadDescriptors.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDThreadDescriptor>> (_o->threadDescriptors.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDThreadDescriptor(*__va->__fbb, __va->__o->threadDescriptors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _constantMappings = _o->constantMappings.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::AICMDConstantMapping>> (_o->constantMappings.size(), [](size_t i, _VectorArgs *__va) { return CreateAICMDConstantMapping(*__va->__fbb, __va->__o->constantMappings[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _staticSharedDDRSize = _o->staticSharedDDRSize;
  auto _dynamicSharedDDRSize = _o->dynamicSharedDDRSize;
  auto _staticConstantsSize = _o->staticConstantsSize;
  auto _dynamicConstantsSize = _o->dynamicConstantsSize;
  auto _exitDoorbellOffset = _o->exitDoorbellOffset;
  auto _l2CachedDDRSize = _o->l2CachedDDRSize;
  auto _L2TCMInitSize = _o->L2TCMInitSize;
  auto _execContextMajorVersion = _o->execContextMajorVersion;
  auto _numNSPs = _o->numNSPs;
  auto _numSemaphores = _o->numSemaphores;
  auto _hwVersionMajor = _o->hwVersionMajor;
  auto _hwVersionMinor = _o->hwVersionMinor;
  auto _staticSharedDDRECCEnabled = _o->staticSharedDDRECCEnabled;
  auto _dynamicSharedDDRECCEnabled = _o->dynamicSharedDDRECCEnabled;
  auto _staticConstantsECCEnabled = _o->staticConstantsECCEnabled;
  auto _dynamicConstantsECCEnabled = _o->dynamicConstantsECCEnabled;
  auto _singleVTCMPage = _o->singleVTCMPage;
  auto _hasHvxFP = _o->hasHvxFP;
  auto _hasHmxFP = _o->hasHmxFP;
  auto _VTCMSize = _o->VTCMSize;
  auto _L2TCMSize = _o->L2TCMSize;
  auto _networkHeapSize = _o->networkHeapSize;
  auto _raw_struct_version_length = _o->raw_struct_version_length;
  auto _QNNConfig = _o->QNNConfig ? CreateQNNConfigDef(_fbb, _o->QNNConfig.get(), _rehasher) : 0;
  auto _portTable = _o->portTable.size() ? _fbb.CreateVectorOfStructs(_o->portTable) : 0;
  auto _execContext = _o->execContext.size() ? _fbb.CreateVector(_o->execContext) : 0;
  auto _L2TCMInitStateNonZeroRegions = _o->L2TCMInitStateNonZeroRegions.size() ? _fbb.CreateVector<flatbuffers::Offset<AicMetadataFlat::NonZeroRegion>> (_o->L2TCMInitStateNonZeroRegions.size(), [](size_t i, _VectorArgs *__va) { return CreateNonZeroRegion(*__va->__fbb, __va->__o->L2TCMInitStateNonZeroRegions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _dynamicSharedDDRSupported = _o->dynamicSharedDDRSupported;
  auto _networkHeapBehavior = _o->networkHeapBehavior ? CreatenetworkHeapBehaviorDef(_fbb, _o->networkHeapBehavior.get(), _rehasher) : 0;
  return AicMetadataFlat::CreateMetadata(
      _fbb,
      _versionMajor,
      _versionMinor,
      _networkName,
      _requiredFields,
      _semaphoreInitState,
      _L2TCMInitState,
      _dmaRequests,
      _nspMulticastTables,
      _hostMulticastTable,
      _threadDescriptors,
      _constantMappings,
      _staticSharedDDRSize,
      _dynamicSharedDDRSize,
      _staticConstantsSize,
      _dynamicConstantsSize,
      _exitDoorbellOffset,
      _l2CachedDDRSize,
      _L2TCMInitSize,
      _execContextMajorVersion,
      _numNSPs,
      _numSemaphores,
      _hwVersionMajor,
      _hwVersionMinor,
      _staticSharedDDRECCEnabled,
      _dynamicSharedDDRECCEnabled,
      _staticConstantsECCEnabled,
      _dynamicConstantsECCEnabled,
      _singleVTCMPage,
      _hasHvxFP,
      _hasHmxFP,
      _VTCMSize,
      _L2TCMSize,
      _networkHeapSize,
      _raw_struct_version_length,
      _QNNConfig,
      _portTable,
      _execContext,
      _L2TCMInitStateNonZeroRegions,
      _dynamicSharedDDRSupported,
      _networkHeapBehavior);
}

inline const flatbuffers::TypeTable *AICHardwareVersionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, 0 },
    { flatbuffers::ET_LONG, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICHardwareVersionTypeTable
  };
  static const int64_t values[] = { 65536LL, 131072LL };
  static const char * const names[] = {
    "AIC_HW_VER_1_0",
    "AIC_HW_VER_2_0"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDSemaphoreOpcodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDSemaphoreOpcodeTypeTable
  };
  static const char * const names[] = {
    "AICMDSemaphoreCmdNOP",
    "AICMDSemaphoreCmdINIT",
    "AICMDSemaphoreCmdINC",
    "AICMDSemaphoreCmdDEC",
    "AICMDSemaphoreCmdWAITEQ",
    "AICMDSemaphoreCmdWAITGE",
    "AICMDSemaphoreCmdP"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDSemaphoreSyncTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDSemaphoreSyncTypeTable
  };
  static const char * const names[] = {
    "AICMDSemaphoreSyncPost",
    "AICMDSemaphoreSyncPre"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDDoorbellOpSizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDDoorbellOpSizeTypeTable
  };
  static const char * const names[] = {
    "AICMDDoorballOpSize8",
    "AICMDDoorballOpSize16",
    "AICMDDoorballOpSize32"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDDMAEntryAddrSpaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDDMAEntryAddrSpaceTypeTable
  };
  static const char * const names[] = {
    "AICMDDMAAddrSpaceMC",
    "AICMDDMAAddrSpaceDDR",
    "AICMDDMAAddrSpaceDDRDynamicShared"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDDMADirectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDDMADirectionTypeTable
  };
  static const char * const names[] = {
    "AICMDDMAIn",
    "AICMDDMAOut"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDPortTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDPortTypeTypeTable
  };
  static const char * const names[] = {
    "AICMDPortUserIO",
    "AICMDPortP2P",
    "AICMDPortMQTH"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDDMAReservedTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDDMAReservedTypeTable
  };
  static const int64_t values[] = { 65535, 4294967295 };
  static const char * const names[] = {
    "AICMDDMABufNumNone",
    "AICMDDMATransactionIdNone"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDMulticastEntryAddrSpaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDMulticastEntryAddrSpaceTypeTable
  };
  static const char * const names[] = {
    "AICMDAddrSpaceL2TCM",
    "AICMDAddrSpaceVTCM"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDThreadTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDThreadTypeTypeTable
  };
  static const int64_t values[] = { 1, 2 };
  static const char * const names[] = {
    "AICMDThreadHMX",
    "AICMDThreadHVX"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *cacheableConstantsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::cacheableConstantsTypeTable
  };
  static const int64_t values[] = { 1, 2 };
  static const char * const names[] = {
    "CACHE_DISABLED",
    "CACHE_ENABLED"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *networkDeactivateActionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::networkDeactivateActionTypeTable
  };
  static const int64_t values[] = { 1, 2 };
  static const char * const names[] = {
    "freeNetworkHeap",
    "preserveNetworkHeap"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDSemaphoreOpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "semNum",
    "semValue",
    "semOp",
    "preOrPost",
    "inSyncFence",
    "outSyncFence"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDDoorbellOpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "offset",
    "data",
    "mcId",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDPortEntryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDPortTypeTypeTable
  };
  static const int64_t values[] = { 0, 2, 4 };
  static const char * const names[] = {
    "portId",
    "portType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDDMARequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDSemaphoreOpTypeTable,
    AicMetadataFlat::AICMDDoorbellOpTypeTable
  };
  static const char * const names[] = {
    "semaphoreOps",
    "doorbellOps",
    "hostOffset",
    "devOffset",
    "size",
    "num",
    "mcId",
    "devAddrSpace",
    "inOut",
    "portId",
    "transactionId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDNSPMulticastEntryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "baseAddrOffset",
    "mask",
    "size",
    "addrSpace",
    "dynamic"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDNSPMulticastEntryTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDNSPMulticastEntryTypeTable
  };
  static const char * const names[] = {
    "multicastEntries"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDHostMulticastEntryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "mask",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDHostMulticastEntryTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDHostMulticastEntryTypeTable
  };
  static const char * const names[] = {
    "multicastEntries"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDThreadDescriptorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "entryPoint",
    "typeMask"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AICMDConstantMappingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "constantDataBaseOffset",
    "coreMask",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QNNConfigDefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::cacheableConstantsTypeTable
  };
  static const char * const names[] = {
    "Constants"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *networkHeapBehaviorDefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::networkDeactivateActionTypeTable
  };
  static const char * const names[] = {
    "onNetworkDeactivate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonZeroRegionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "start",
    "end",
    "size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MetadataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 4 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 7 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 8 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AicMetadataFlat::AICMDDMARequestTypeTable,
    AicMetadataFlat::AICMDNSPMulticastEntryTableTypeTable,
    AicMetadataFlat::AICMDHostMulticastEntryTableTypeTable,
    AicMetadataFlat::AICMDThreadDescriptorTypeTable,
    AicMetadataFlat::AICMDConstantMappingTypeTable,
    AicMetadataFlat::QNNConfigDefTypeTable,
    AicMetadataFlat::AICMDPortEntryTypeTable,
    AicMetadataFlat::NonZeroRegionTypeTable,
    AicMetadataFlat::networkHeapBehaviorDefTypeTable
  };
  static const char * const names[] = {
    "versionMajor",
    "versionMinor",
    "networkName",
    "requiredFields",
    "semaphoreInitState",
    "L2TCMInitState",
    "dmaRequests",
    "nspMulticastTables",
    "hostMulticastTable",
    "threadDescriptors",
    "constantMappings",
    "staticSharedDDRSize",
    "dynamicSharedDDRSize",
    "staticConstantsSize",
    "dynamicConstantsSize",
    "exitDoorbellOffset",
    "l2CachedDDRSize",
    "L2TCMInitSize",
    "execContextMajorVersion",
    "numNSPs",
    "numSemaphores",
    "hwVersionMajor",
    "hwVersionMinor",
    "staticSharedDDRECCEnabled",
    "dynamicSharedDDRECCEnabled",
    "staticConstantsECCEnabled",
    "dynamicConstantsECCEnabled",
    "singleVTCMPage",
    "hasHvxFP",
    "hasHmxFP",
    "VTCMSize",
    "L2TCMSize",
    "networkHeapSize",
    "raw_struct_version_length",
    "QNNConfig",
    "portTable",
    "execContext",
    "L2TCMInitStateNonZeroRegions",
    "dynamicSharedDDRSupported",
    "networkHeapBehavior"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 40, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const AicMetadataFlat::Metadata *GetMetadata(const void *buf) {
  return flatbuffers::GetRoot<AicMetadataFlat::Metadata>(buf);
}

inline const AicMetadataFlat::Metadata *GetSizePrefixedMetadata(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<AicMetadataFlat::Metadata>(buf);
}

inline bool VerifyMetadataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AicMetadataFlat::Metadata>(nullptr);
}

inline bool VerifySizePrefixedMetadataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AicMetadataFlat::Metadata>(nullptr);
}

inline void FinishMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AicMetadataFlat::Metadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AicMetadataFlat::Metadata> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<AicMetadataFlat::MetadataT> UnPackMetadata(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<AicMetadataFlat::MetadataT>(GetMetadata(buf)->UnPack(res));
}

inline std::unique_ptr<AicMetadataFlat::MetadataT> UnPackSizePrefixedMetadata(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<AicMetadataFlat::MetadataT>(GetSizePrefixedMetadata(buf)->UnPack(res));
}

}  // namespace AicMetadataFlat

#endif  // FLATBUFFERS_GENERATED_AICMETADATAFLAT_AICMETADATAFLAT_H_
