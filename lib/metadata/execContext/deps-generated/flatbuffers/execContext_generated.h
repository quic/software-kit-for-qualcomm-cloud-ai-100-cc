// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECCONTEXT_EXECCONTEXT_H_
#define FLATBUFFERS_GENERATED_EXECCONTEXT_EXECCONTEXT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace ExecContext {

struct execContextField;
struct execContextFieldBuilder;
struct execContextFieldT;

struct execContext;
struct execContextBuilder;
struct execContextT;

enum execContextVariables : uint32_t {
  execContextVariables_execContextMajorVersion = 0,
  execContextVariables_execContextMinorVersion = 1,
  execContextVariables_virtualNSPId = 2,
  execContextVariables_baseL2TCM = 3,
  execContextVariables_baseVTCM = 4,
  execContextVariables_baseConstantDataMem = 5,
  execContextVariables_baseSharedDDR = 6,
  execContextVariables_baseL2CachedDDR = 7,
  execContextVariables_mcAddresses = 8,
  execContextVariables_startTimeStamp = 9,
  execContextVariables_logFuncPtr = 10,
  execContextVariables_exitThread = 11,
  execContextVariables_setPMUReg = 12,
  execContextVariables_errFuncPtr = 13,
  execContextVariables_notifyHangPtr = 14,
  execContextVariables_udmaReadFuncPtr = 15,
  execContextVariables_mmapFuncPtr = 16,
  execContextVariables_munmapFuncPtr = 17,
  execContextVariables_qdssSTMPortVaddr = 18,
  execContextVariables_readPMUCnt = 19,
  execContextVariables_ddrBWMonRegVaddr = 20,
  execContextVariables_semaphoreListPtr = 21,
  execContextVariables_networkHeapAddr = 22,
  execContextVariables_networkHeapSize = 23,
  execContextVariables_reprogMcidFuncPtr = 24,
  execContextVariables_dlOpenPtr = 25,
  execContextVariables_dlOpenbufPtr = 26,
  execContextVariables_dlClosePtr = 27,
  execContextVariables_dlSymPtr = 28,
  execContextVariables_dlAddrPtr = 29,
  execContextVariables_dlErrorPtr = 30,
  execContextVariables_dlInfoPtr = 31,
  execContextVariables_baseUtcOffsetDDR = 32,
  execContextVariables_MIN = execContextVariables_execContextMajorVersion,
  execContextVariables_MAX = execContextVariables_baseUtcOffsetDDR
};

inline const execContextVariables (&EnumValuesexecContextVariables())[33] {
  static const execContextVariables values[] = {
    execContextVariables_execContextMajorVersion,
    execContextVariables_execContextMinorVersion,
    execContextVariables_virtualNSPId,
    execContextVariables_baseL2TCM,
    execContextVariables_baseVTCM,
    execContextVariables_baseConstantDataMem,
    execContextVariables_baseSharedDDR,
    execContextVariables_baseL2CachedDDR,
    execContextVariables_mcAddresses,
    execContextVariables_startTimeStamp,
    execContextVariables_logFuncPtr,
    execContextVariables_exitThread,
    execContextVariables_setPMUReg,
    execContextVariables_errFuncPtr,
    execContextVariables_notifyHangPtr,
    execContextVariables_udmaReadFuncPtr,
    execContextVariables_mmapFuncPtr,
    execContextVariables_munmapFuncPtr,
    execContextVariables_qdssSTMPortVaddr,
    execContextVariables_readPMUCnt,
    execContextVariables_ddrBWMonRegVaddr,
    execContextVariables_semaphoreListPtr,
    execContextVariables_networkHeapAddr,
    execContextVariables_networkHeapSize,
    execContextVariables_reprogMcidFuncPtr,
    execContextVariables_dlOpenPtr,
    execContextVariables_dlOpenbufPtr,
    execContextVariables_dlClosePtr,
    execContextVariables_dlSymPtr,
    execContextVariables_dlAddrPtr,
    execContextVariables_dlErrorPtr,
    execContextVariables_dlInfoPtr,
    execContextVariables_baseUtcOffsetDDR
  };
  return values;
}

inline const char * const *EnumNamesexecContextVariables() {
  static const char * const names[34] = {
    "execContextMajorVersion",
    "execContextMinorVersion",
    "virtualNSPId",
    "baseL2TCM",
    "baseVTCM",
    "baseConstantDataMem",
    "baseSharedDDR",
    "baseL2CachedDDR",
    "mcAddresses",
    "startTimeStamp",
    "logFuncPtr",
    "exitThread",
    "setPMUReg",
    "errFuncPtr",
    "notifyHangPtr",
    "udmaReadFuncPtr",
    "mmapFuncPtr",
    "munmapFuncPtr",
    "qdssSTMPortVaddr",
    "readPMUCnt",
    "ddrBWMonRegVaddr",
    "semaphoreListPtr",
    "networkHeapAddr",
    "networkHeapSize",
    "reprogMcidFuncPtr",
    "dlOpenPtr",
    "dlOpenbufPtr",
    "dlClosePtr",
    "dlSymPtr",
    "dlAddrPtr",
    "dlErrorPtr",
    "dlInfoPtr",
    "baseUtcOffsetDDR",
    nullptr
  };
  return names;
}

inline const char *EnumNameexecContextVariables(execContextVariables e) {
  if (flatbuffers::IsOutRange(e, execContextVariables_execContextMajorVersion, execContextVariables_baseUtcOffsetDDR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesexecContextVariables()[index];
}

enum requiredDef : uint32_t {
  requiredDef_required = 0,
  requiredDef_optional = 1,
  requiredDef_MIN = requiredDef_required,
  requiredDef_MAX = requiredDef_optional
};

inline const requiredDef (&EnumValuesrequiredDef())[2] {
  static const requiredDef values[] = {
    requiredDef_required,
    requiredDef_optional
  };
  return values;
}

inline const char * const *EnumNamesrequiredDef() {
  static const char * const names[3] = {
    "required",
    "optional",
    nullptr
  };
  return names;
}

inline const char *EnumNamerequiredDef(requiredDef e) {
  if (flatbuffers::IsOutRange(e, requiredDef_required, requiredDef_optional)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesrequiredDef()[index];
}

struct execContextFieldT : public flatbuffers::NativeTable {
  typedef execContextField TableType;
  ExecContext::execContextVariables variableNeeded = ExecContext::execContextVariables_execContextMajorVersion;
  uint32_t variableSize = 0;
  uint64_t execContextOffset = 0;
  ExecContext::requiredDef isRequired = ExecContext::requiredDef_required;
};

struct execContextField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef execContextFieldT NativeTableType;
  typedef execContextFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLENEEDED = 4,
    VT_VARIABLESIZE = 6,
    VT_EXECCONTEXTOFFSET = 8,
    VT_ISREQUIRED = 10
  };
  ExecContext::execContextVariables variableNeeded() const {
    return static_cast<ExecContext::execContextVariables>(GetField<uint32_t>(VT_VARIABLENEEDED, 0));
  }
  uint32_t variableSize() const {
    return GetField<uint32_t>(VT_VARIABLESIZE, 0);
  }
  uint64_t execContextOffset() const {
    return GetField<uint64_t>(VT_EXECCONTEXTOFFSET, 0);
  }
  ExecContext::requiredDef isRequired() const {
    return static_cast<ExecContext::requiredDef>(GetField<uint32_t>(VT_ISREQUIRED, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VARIABLENEEDED, 4) &&
           VerifyField<uint32_t>(verifier, VT_VARIABLESIZE, 4) &&
           VerifyField<uint64_t>(verifier, VT_EXECCONTEXTOFFSET, 8) &&
           VerifyField<uint32_t>(verifier, VT_ISREQUIRED, 4) &&
           verifier.EndTable();
  }
  execContextFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(execContextFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<execContextField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const execContextFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct execContextFieldBuilder {
  typedef execContextField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variableNeeded(ExecContext::execContextVariables variableNeeded) {
    fbb_.AddElement<uint32_t>(execContextField::VT_VARIABLENEEDED, static_cast<uint32_t>(variableNeeded), 0);
  }
  void add_variableSize(uint32_t variableSize) {
    fbb_.AddElement<uint32_t>(execContextField::VT_VARIABLESIZE, variableSize, 0);
  }
  void add_execContextOffset(uint64_t execContextOffset) {
    fbb_.AddElement<uint64_t>(execContextField::VT_EXECCONTEXTOFFSET, execContextOffset, 0);
  }
  void add_isRequired(ExecContext::requiredDef isRequired) {
    fbb_.AddElement<uint32_t>(execContextField::VT_ISREQUIRED, static_cast<uint32_t>(isRequired), 0);
  }
  explicit execContextFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<execContextField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<execContextField>(end);
    return o;
  }
};

inline flatbuffers::Offset<execContextField> CreateexecContextField(
    flatbuffers::FlatBufferBuilder &_fbb,
    ExecContext::execContextVariables variableNeeded = ExecContext::execContextVariables_execContextMajorVersion,
    uint32_t variableSize = 0,
    uint64_t execContextOffset = 0,
    ExecContext::requiredDef isRequired = ExecContext::requiredDef_required) {
  execContextFieldBuilder builder_(_fbb);
  builder_.add_execContextOffset(execContextOffset);
  builder_.add_isRequired(isRequired);
  builder_.add_variableSize(variableSize);
  builder_.add_variableNeeded(variableNeeded);
  return builder_.Finish();
}

flatbuffers::Offset<execContextField> CreateexecContextField(flatbuffers::FlatBufferBuilder &_fbb, const execContextFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct execContextT : public flatbuffers::NativeTable {
  typedef execContext TableType;
  uint32_t execContextSize = 0;
  std::vector<std::unique_ptr<ExecContext::execContextFieldT>> execContextFields{};
  execContextT() = default;
  execContextT(const execContextT &o);
  execContextT(execContextT&&) FLATBUFFERS_NOEXCEPT = default;
  execContextT &operator=(execContextT o) FLATBUFFERS_NOEXCEPT;
};

struct execContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef execContextT NativeTableType;
  typedef execContextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXECCONTEXTSIZE = 4,
    VT_EXECCONTEXTFIELDS = 6
  };
  uint32_t execContextSize() const {
    return GetField<uint32_t>(VT_EXECCONTEXTSIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ExecContext::execContextField>> *execContextFields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ExecContext::execContextField>> *>(VT_EXECCONTEXTFIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EXECCONTEXTSIZE, 4) &&
           VerifyOffset(verifier, VT_EXECCONTEXTFIELDS) &&
           verifier.VerifyVector(execContextFields()) &&
           verifier.VerifyVectorOfTables(execContextFields()) &&
           verifier.EndTable();
  }
  execContextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(execContextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<execContext> Pack(flatbuffers::FlatBufferBuilder &_fbb, const execContextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct execContextBuilder {
  typedef execContext Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_execContextSize(uint32_t execContextSize) {
    fbb_.AddElement<uint32_t>(execContext::VT_EXECCONTEXTSIZE, execContextSize, 0);
  }
  void add_execContextFields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExecContext::execContextField>>> execContextFields) {
    fbb_.AddOffset(execContext::VT_EXECCONTEXTFIELDS, execContextFields);
  }
  explicit execContextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<execContext> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<execContext>(end);
    return o;
  }
};

inline flatbuffers::Offset<execContext> CreateexecContext(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t execContextSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExecContext::execContextField>>> execContextFields = 0) {
  execContextBuilder builder_(_fbb);
  builder_.add_execContextFields(execContextFields);
  builder_.add_execContextSize(execContextSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<execContext> CreateexecContextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t execContextSize = 0,
    const std::vector<flatbuffers::Offset<ExecContext::execContextField>> *execContextFields = nullptr) {
  auto execContextFields__ = execContextFields ? _fbb.CreateVector<flatbuffers::Offset<ExecContext::execContextField>>(*execContextFields) : 0;
  return ExecContext::CreateexecContext(
      _fbb,
      execContextSize,
      execContextFields__);
}

flatbuffers::Offset<execContext> CreateexecContext(flatbuffers::FlatBufferBuilder &_fbb, const execContextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline execContextFieldT *execContextField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<execContextFieldT>(new execContextFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void execContextField::UnPackTo(execContextFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = variableNeeded(); _o->variableNeeded = _e; }
  { auto _e = variableSize(); _o->variableSize = _e; }
  { auto _e = execContextOffset(); _o->execContextOffset = _e; }
  { auto _e = isRequired(); _o->isRequired = _e; }
}

inline flatbuffers::Offset<execContextField> execContextField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const execContextFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateexecContextField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<execContextField> CreateexecContextField(flatbuffers::FlatBufferBuilder &_fbb, const execContextFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const execContextFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _variableNeeded = _o->variableNeeded;
  auto _variableSize = _o->variableSize;
  auto _execContextOffset = _o->execContextOffset;
  auto _isRequired = _o->isRequired;
  return ExecContext::CreateexecContextField(
      _fbb,
      _variableNeeded,
      _variableSize,
      _execContextOffset,
      _isRequired);
}

inline execContextT::execContextT(const execContextT &o)
      : execContextSize(o.execContextSize) {
  execContextFields.reserve(o.execContextFields.size());
  for (const auto &execContextFields_ : o.execContextFields) { execContextFields.emplace_back((execContextFields_) ? new ExecContext::execContextFieldT(*execContextFields_) : nullptr); }
}

inline execContextT &execContextT::operator=(execContextT o) FLATBUFFERS_NOEXCEPT {
  std::swap(execContextSize, o.execContextSize);
  std::swap(execContextFields, o.execContextFields);
  return *this;
}

inline execContextT *execContext::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<execContextT>(new execContextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void execContext::UnPackTo(execContextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = execContextSize(); _o->execContextSize = _e; }
  { auto _e = execContextFields(); if (_e) { _o->execContextFields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->execContextFields[_i]) { _e->Get(_i)->UnPackTo(_o->execContextFields[_i].get(), _resolver); } else { _o->execContextFields[_i] = std::unique_ptr<ExecContext::execContextFieldT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->execContextFields.resize(0); } }
}

inline flatbuffers::Offset<execContext> execContext::Pack(flatbuffers::FlatBufferBuilder &_fbb, const execContextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateexecContext(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<execContext> CreateexecContext(flatbuffers::FlatBufferBuilder &_fbb, const execContextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const execContextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _execContextSize = _o->execContextSize;
  auto _execContextFields = _o->execContextFields.size() ? _fbb.CreateVector<flatbuffers::Offset<ExecContext::execContextField>> (_o->execContextFields.size(), [](size_t i, _VectorArgs *__va) { return CreateexecContextField(*__va->__fbb, __va->__o->execContextFields[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ExecContext::CreateexecContext(
      _fbb,
      _execContextSize,
      _execContextFields);
}

inline const ExecContext::execContext *GetexecContext(const void *buf) {
  return flatbuffers::GetRoot<ExecContext::execContext>(buf);
}

inline const ExecContext::execContext *GetSizePrefixedexecContext(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ExecContext::execContext>(buf);
}

inline bool VerifyexecContextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ExecContext::execContext>(nullptr);
}

inline bool VerifySizePrefixedexecContextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ExecContext::execContext>(nullptr);
}

inline void FinishexecContextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ExecContext::execContext> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedexecContextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ExecContext::execContext> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ExecContext::execContextT> UnPackexecContext(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ExecContext::execContextT>(GetexecContext(buf)->UnPack(res));
}

inline std::unique_ptr<ExecContext::execContextT> UnPackSizePrefixedexecContext(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ExecContext::execContextT>(GetSizePrefixedexecContext(buf)->UnPack(res));
}

}  // namespace ExecContext

#endif  // FLATBUFFERS_GENERATED_EXECCONTEXT_EXECCONTEXT_H_
